## 面试题

几年前，有一个小伙伴问过我一道面试题：13个人手拉手围成一个圈，假设从`1号`开始报数1，他的下一位`2号`报数2，再下一位`3号`报数3，当报数是3的人（即`3号`）退出圈，他的前后两人（即`2号`和`4号`）重新拉上手，然后从`4号`开始重复上述过程，这样经过若干次后这个圈会最终剩下一个人，那么请问最后这个人是谁，请写出程序找到这个人。  
![](https://pan.udolphin.com/files/image/2021/11/ee99b410117ebd005b2ff9e7ad60ba3a.gif)

## 朴素解

看到这道题，我的第一感觉是模拟整个过程从而找到最后剩下的那个人。同时很快意识到这题的考点是`链表`。我相信大多数小伙伴和我的认识是一样的。下面给出我的实现。

```
function find(person, countNumber) {
  let nodes = new Array();
  for (let i = 0; i < person; i++) {
    let node = new Object();
    node.id = i + 1;
    nodes.push(node);
  }
  for (let i = 0; i < nodes.length; i++) {
    if (i == nodes.length - 1) {
      nodes[i].next = nodes[0];
    } else {
      nodes[i].next = nodes[i + 1];
    }
    if (i == 0) {
      nodes[i].prev = nodes[nodes.length - 1];
    } else {
      nodes[i].prev = nodes[i - 1];
    }
  }

  let curNode = nodes[0];
  let count = 0;
  while (true) {
    let nextNode = curNode.next;
    if (count == countNumber - 1) {
      let prevNode = curNode.prev;
      if (nextNode.id == prevNode.id) {
        curNode = nextNode;
        break;
      } else {
        prevNode.next = nextNode;
        nextNode.prev = prevNode;
        curNode = nextNode;
      }
      count = 0;
    } else {
      curNode = nextNode;
      count++;
    }
  }
  return curNode.id;
}
```

## 隐患

上面的解看似完美的解出了这道题，但总感觉哪里不太对。这个感觉纠缠了我一周。假如不是`13人围成圈`，而是`13亿人围成圈`，程序会怎么样呢？首先，内存肯定是爆了，内存放不下13亿对象的链表。其次，即便有一个超级内存可以容纳下13亿对象的链表，循环次数会是`（1300000000 - 1）* 3`次，显然时间复杂度上也是不能接受的。那怎么办呢？

## 探索过程

在之后的一个周六，这个感觉越发强烈，好像神在驱使我必须解决这个问题。我首先意识到，基于`链表`的思路，不管怎么优化算法，始终绕不开`模拟循环报数的次数`。这是一个好的开始，因为我发现了`链表`思路的本质问题。我们让计算机模拟业务的全过程，按现在流行的说法，这是在`把围圈报数游戏数字孪生`。`数字孪生体`被要求和`现实孪生体`一模一样，而`现实孪生体`本身就是要循环那么多次，所以我们不管怎样`数字孪生`，永远不可能跳出`现实孪生体`的约束。

然后，我尝试把`围圈人数`从2到1000的结果打印出来，看看有什么启发。

```
2,2,1,4,1,4,7,1,4,7,10,13,2,5,8,11,14,17,20,2,5,8,11,14,17,20,23,26,29,1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,2,5,8,11,14,17,20,23,26,29,32,35,38,41...
```

看到结果我震惊了，发现这串数字是由一段一段的等差数列组成的，这难道是我的`达芬奇密码`吗？怀着激动的心情，我意识到它是一个数学问题，解是有规律的。既然解随入参规律变化而规律变化，我们应该可以找到一个`恰当的函数`来描述这个现象。（这一步是最关键的一步，为何从这个尝试来入手，说实在的纯粹是瞎蒙，也可能这就是`神的指引`吧。）

虽然已经从数列中发现了规律，但这还不够直观，需要对数列进行一定的可视化，从而发现更多规律。下图是`报数为3`的函数图，横坐标是`围圈人数`，纵坐标是`剩下的那个人的编号`。  
![image.png](https://pan.udolphin.com/files/image/2021/11/bc3f2afcb45384db74c9dcce4196fbcf.png)  
我们可以发现，函数由若干个斜率为正的直线组成，这些直线是平行的（即斜率=数列公差=3），这些直线按一定的周期会做一次`归零`操作。进一步，我们把所有`归零`的点连起来，能发现这些点似乎在另一条直线上，这条直线是`f(x) = x`。  
![image.png](https://pan.udolphin.com/files/image/2021/11/14014e4ed273855eef05bc565b906b2c.png)

考察完`报数为3`的函数图，我又去绘制了`报数为5、7、12`的函数图，结论是我再次被震惊了。  
![image.png](https://pan.udolphin.com/files/image/2021/11/2d3ac99dd0afaf11bcf8a3f9cbedf165.png)  
![image.png](https://pan.udolphin.com/files/image/2021/11/c05bc8c03907e7290a6d00181cc9235f.png)  
![image.png](https://pan.udolphin.com/files/image/2021/11/87ce117348f29344b86722b30214f67a.png)  
上述规律基本都重现了，唯一不同的是斜率分别为5、7、12。报数我特意选取了既有`质数`又有`合数`的情况，说明这些规律是普遍的，和`报数选取几`应该是没关系的，同时进一步能发现数列公差就是报数的数字。

按照上述规律，尝试总结出那个`恰当的函数`。我们只要知道`围圈人数`处于哪个直线周期，同时确定那个直线周期`f(x) = kx + b`的k和b，就可以一步到位计算出最终剩下的那个人的编号了。k很好确定，就是`报数选取几`。我们再来观察一下这个数列。

```
用中括号隔开相邻的直线周期
最终那人：[2],[2],[1,4],[1,4,7],[1, 4, 7,10,13],[ 2, 5, 8,11,14,17,20],[ 2, 5, 8,11,14,17,20,23,26,29],[ 1, 4, 7,10,13,16,19,22,25,28,31,34,37,40,43,46],[ 2, 5, 8,11,14,17,20,23,26,29,32,35,38,41...
围圈人数：[2],[3],[4,5],[6,7,8],[9,10,11,12,13],[14,15,16,17,18,19,20],[21,22,23,24,25,26,27,28,29,30],[31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46],[47,48,49,50,51,52,53,54,55,56,57,58,59,60...
```

这里先要理解下为什么会有`周期归零`的现象。假设没有`周期归零`，当`围圈人数`是9时，我们猜想`最终那人`是`7 + 3 = 10`，这样就会形成悖论：总共有9个人围圈，但最终剩下的人是10号，10号人是不存在的，因为总共就9个人。这样我们也可以理解图中`红色箭头`函数为什么是`f(x) = x`了，因为`最终那人`不能超过`围圈人数`。我们再来看一下刚才的猜想，当`围圈人数`是9时，按上一个直线周期1（6）、4（7）、7（8），它应该是10（9），但是受`围圈人数`的限制，这时应该`归零`，我们再看一下实际的值是1（9）。这就很有意思了，`10 - 9 = 1`。同学们可以去自己算算其他`周期归零`时的情况，都是符合这个规律的。

## 高级解

按照上述规律，总结下算法过程。

`入参取值范围`：`围圈人数`为大于1的正整数，`报数是几`为正整数。

`步骤1`：当`报数是1`时，`最终那人`的编号是`围圈人数`的值。

`步骤2`：确定当`报数大于1`时`数列首项`（围圈人数为2）的值。当`报数是偶数`时，`数列首项`是1；当`报数是奇数`时，`数列首项`是2。

`步骤3`：确定`围圈人数`处于哪个周期的直线（`f(x) = kx + b`）上，并计算出对应的k和b，最后把`围圈人数`代入到`f(x)`中，计算出`最终那人`的编号。k的值是`报数是几`，代入当前`数列首项`的(x, y)，求解出：b = `数列首项y` - `报数是几` \* `数列首项x`。确定k和b后，计算`f(x) = kx + b`和`g(x) = x`两条直线的交点的x值，即`b / (1 - k)`。若`围圈人数`小于等于交点的x值，则把`围圈人数`代入到`f(x) = kx + b`中，计算出`最终那人`的编号；反之，则确定下一周期直线的首项，即( floor(交点的x值) + 1, k \* (floor(交点的x值) + 1) + b - (floor(交点的x值) + 1) )，重复本步骤。

下面是代码实现

```
function findAdvanced(person, countNumber) {
  if (countNumber == 1) {
    return person;
  } else {
    let startX = 2;
    let startY = (countNumber % 2) + 1;
    let judas = null;
    while (true) {
      const b = startY - countNumber * startX;
      let crossX = Math.floor(b / (1 - countNumber));
      if (person > crossX) {
        startX = crossX + 1;
        startY = countNumber * startX + b - startX;
      } else {
        judas = countNumber * person + b;
        break;
      }
    }
    return judas;
  }
}
```

## 感想

我们在写程序时候本能能设计出的算法一般都是按照题目或业务逻辑用模拟的思路来构建的，我对这类算法称为朴素算法，而对于较复杂的问题朴素算法往往不是最优解。这就需要我们运用其他的一些知识来优化甚至重写朴素算法。其中最重要的一种知识就是数学。而我们一般都是凡人，很少有经过正规数学训练的经历，也没有很强的抽象能力，所以我们很难从本质上分析解决问题。但是我们可以通过一些辅助手段来接近问题的本质，比如可视化方式就是一种，可视化就是把抽象的东西形象化，能让我们这些凡人也能理解一些深奥的东西。最后，本文只是从现象本身总结出了一些规律，从而利用这些规律辅助解题，并没有对这些规律进行严谨的数学证明，欢迎与有兴趣的同学一起研究讨论。