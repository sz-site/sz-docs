# **什么是操作系统**

**从语义上可以理解为"管理 ‘操作’ 的系统"，给一个具体点的定义——管理软/硬件资源，“为程序提供服务”的程序（广义上）**

![](https://pan.udolphin.com/files/image/2022/6/4477c1b680dd8b5d1cb51e7fe375cec8.png)

如果管理目标任意更换的话，任何管理目标的对象都可以称为**操作系统。**例如：校长管理学生，分配资源（入学，升学，毕业）。管理对象是学生，分配资源给学生，为学生提供服务。校长是不是也可以称为操作系统？

# **常见的操作系统**

**操作系统 (operating system，简称OS)**是**管理计算机硬件与软件资源的计算机程序**。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互操作的界面。

> **三个重要的线索：**
>
> **计算机硬件**
>
> **程序（软件）**
>
> **操作系统（管理软件的软件）**

![](https://pan.udolphin.com/files/image/2022/6/18cdb24f1d47add3c9bf697b75b30ae7.png)

# **从图灵机到现代操作系统**

**随着硬件的提升，计算机发生了很大的变化，操作系统也得到了发展。操作系统形成现在状态是有其历史原因的，所以我们先来看一下，计算机以及操作系统的发展历史。**

**以下例子是一些原理的实现，实际会更复杂。**

## **图灵机**

1936年11月12日，**阿兰·图灵(Alan Turing)**发表了计算机理论的奠基性论文《论可计算数及其在判定问题中的应用》(On Computable Numbers, with Application to the Entscheidungsproblem)。阐明了现代计算机理论，从理论上定义了现代通用计算机，可计算性等重要概念。

![](https://pan.udolphin.com/files/image/2022/7/9bf908476347dd0afec0b1dce458e1e5.png)

##### **他提出一台能实现数字计算和逻辑判断的机器必须具备以下功能：**

> 1.**一条无限长的纸带。**纸带分为一个个格子，每个格子里有一个来自有限字母表的字母，字母表中有一个空白符号。纸带上的格子被编号为0, 1, 2, …，纸带一端可以无限伸展。
>
> 2.**一个扫描器。**扫描器能沿着纸带移动，能读出当前所在格子内的字母，并能改变该字母。
>
> 3.**一套控制规则。**它根据图灵机的当前状态及当前扫描器读出的字母来决定扫描器的下一步动作，并改变状态寄存器中寄存的状态，令图灵机进入新状态。
>
> 4.**一个状态寄存器。**它用来保存图灵机的当前状态。图灵机的所有可能状态的数目是有限的，并且有一个特殊状态——停机状态。

**满足上面这四个条件的机器就是有名的图灵机**。图灵的这篇论文把奥地利数学家库尔特·哥德尔(Kurt Godel)在1931年给出的**不可能性定理**，用图灵机精确地表达了出来。

##### **不可能性定理**

**任意一个包含一阶谓词逻辑与初等数论的形式系统，都存在一个命题，它在这个系统中既不能被证明为真，也不能被证明为否。作为哥德尔不完备性定理的第一定理，这说明在一个公理系统中，总有一些命题，我们是拿他们没办法的，就像是悖论一样。如果想要证明或者证伪这些命题，就需要额外增加公理的数量。**

> **例如：**
>
> **线段公理：两点之间线段最短。**
>
> **直线定理：两点确定一条直线**

**两点之间线段最短。**没有办法通过已知条件来证明真伪，还需要增加额外的公理——**两点确定一条直线**。

图灵对计算机理论的重要贡献之一是给出了**停机问题**，即数理逻辑中的可计算性问题。它问的是“能否判断任意一个程序会在有限时间内结束运行”这样一个问题。

> 用数学语言来表示就是：**给定一个程序P和输入I, 程序P在输入I下是否会停止？**

**图灵证明了图灵定理——不存在可以判断停机问题的通用算法。**证明给出了计算机和程序的纯数学定义——图灵机。

**图灵定理告诉我们，停机问题在图灵机上是不可判定问题。**从数理逻辑的观点来看，停机问题说的就是一阶逻辑的不完备性。因此，**图灵机的本质是哥德尔不完备定理的另一种表述，**图灵机是哥德尔的以通用算术为基础的一种形式语言。图灵因其图灵机和图灵定理，被认为是计算机科学之父。

##### **图灵机的计算方式。**

我们已知一个图灵机计算需要：**一条无限长的纸带，一个扫描器，一套控制规则，一个状态寄存器。**我们来看一下它是怎么计算的。

**我们假设输入的纸带的字符串是“#1011#”，我们用“#”号来识别这个二进制数字的起始位置与结束位置，给这个值进行自增操作。**

![](https://pan.udolphin.com/files/image/2022/6/ad99cb3f98a340218ca3ce27ed4a1064.png)

##### **按照****控制文件（指令），纸带（数据），状态存储器，扫描器** **这几个条件。我们继续来看一下，****4+3是怎么计算的** **（**[**4+3是怎么计算的——视频详解**](https://www.bilibili.com/video/BV1br4y1N762?mid=1501845529&p=1&share_from=ugc&share_medium=android&share_plat=android&share_session_id=0b790a1e-f6d7-4290-a89d-f58b97705d21&share_source=WEIXIN&share_tag=s_i&timestamp=1657928847&unique_k=kgCGfe5)**）。**

![](https://pan.udolphin.com/files/image/2022/6/93231264762366401a98a4e19859e473.png)

我们可以一步步得执行上面的指令，根据指令的执行过程来对两个数进行相加操作操作。可以发现，确实能够正确地得到结果。即使我们发现上面的算法是有问题的，那么我们只需要调整算法，调整指令集，直到它能正确地计算结果，**根据需求定制图灵机**。

## **通用图灵机**

图灵机的本质，首先它代表的是一种指令模式。凡是能执行该种模式的机器都是图灵机。为了解决特定问题，我们首先**想出解决问题的算法**，然后**根据算法过程设计图灵机指令集**。我们可以看到，**不同的图灵机之间，除了指令集不同之外，其它各个部分都是一样的。**

我们现在已经有了一个能进行二进制数自增的图灵机，当我们想要进行二进制数相乘或其他算法的图灵机时，我们不必要重新全新地制造一个图灵机，而只需要替换掉二进制自增图灵机的指令集就可以了。

**我们能否设计这样一个超级图灵机**，它的输入，不仅仅是数据，也包括指令集。利用这个超级图灵机，我们就不必要为解决每个特定的问题而专门制作一个图灵机，而只需要把为它们设计的指令集于数据，一起输入这个超级图灵机，它也能够像普通图灵机一样输出正确的答案。我们把这个超级图灵机称为“通用图灵机”，它能够模拟所有的图灵机，**只需要把任何图灵机的指令集连同数据输入给它，效果跟在普通图灵机上执行一样。**

**要想把指令集作为输入，我们首先要做的是把指令集进行编码，写到纸带上。指令集书写在纸带上的位置，我们可以选择与数据书写的位置不一样的地方。就像下图那样，纸带的开头部分用来存储指令集：**

![](https://pan.udolphin.com/files/image/2022/6/3cbcffd804e254a18c43f2fa98e10b62.png)

机器开始运行后，读写头从纸带的左边开始读取，也就是从指令集部分开始读取，我们可以把每个指令编码为固定数目的格子，例如32个格子。这样当机器开始运行后，它将首先读取最左边的32个格子，得到第一条指令。加入第一条指令如下：

> *状态q0：如果读到“#”，状态改为q1，并往右移动一格。否则，状态保持为q0，并往右移动一格。*
>
> 然后把读写头移动到数据的开头部分。这样，图灵机就得到了一条指令，以及一个输入，就可以知道下一步应该做什么，例如，读到了“#”把状态改为q1，并把数据输入部分的位置移到下一格。
>
> 然后，读写头会回到指令集部分加载q1状态的指令：
>
> *状态q1：如果读到“#”，状态改为q2，并往左移动一格。否则，状态保持为q1，并往右移动一格。*
>
> 当读取完这个指令后，它的读写头将回到数据部分未读部分开头的位置去读取数据。例如读到“1”。

循环反复执行上述过程，直至完成。

![](https://pan.udolphin.com/files/image/2022/6/fce3f468294a81bc06ef0de4036e0b19.png)

根据电子计算机采用的物理器件的发展，接下来将电子计算机的发展分成如下五个阶段。

## **在1940s年的系统（数字电路）**

世界上第一台数字式电子计算机诞生于**1946年2月14日**，由美国宾夕法尼亚大学物理学家莫克利（J.Mauchly）和工程师埃克特（J.P.Eckert）等人共同开发的“电子数值积分计算机”（Electronic Numerical Integrator And Computer，简称ENIAC），中文名译为“埃尼阿克”

它的实现非常简单，采用电子管作为主要电子器件，**输入输出都在穿孔的纸带卡片上进行（光敏电阻区分0101）。**由于当时技术的限制，**每秒运算为几千次至几万次**，**内存容量仅为几KB（1024B \* 8）,用了一万八千个真空管。**

![](https://pan.udolphin.com/files/image/2022/6/ff5d23730afb38371c9e091cef7d2b26.png)

软件处于初始阶段，程序设计使用机器语言和汇编语言。体积庞大，功耗大，运算速度低，可靠性差且维护困难，造价很高，主要用于**科学计算**。

这台计算机每秒能完成5000次十进制加法运算，400次乘法运算，比当时最快的计算工具快300倍，是继电器 计算机的1000倍、手工计算的20万倍。但是埃尼阿克并不完善，它**没有存储器，只有寄存器，仅能寄存10个数码。**而且耗电惊人，当时的一个笑话说，只要它一开机，整个费城的路灯都会变暗。

计算机界有名的“debug”一词也来自埃尼阿克，因为埃尼阿克中的电线常被虫子（bug）咬断，检修人员常常要到机器里去查找被咬断的电线，再把它接上，于是寻错就被**“debug”**一词取代。

[**第一代计算机**](https://baike.baidu.com/item/%E7%AC%AC%E4%B8%80%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA)**的特点是操作指令是为特定任务而编制的，输入和输入还是以打孔纸带的方式，每种机器有各自不同的**[**机器语言**](https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80)**，功能受到限制，速度也慢。**

**每次计算重新布线和录入，设置加法，乘法表等指令。**

![](https://pan.udolphin.com/files/image/2022/6/c61c8ad191b8b1df2d94c0ca050344d0.png)

##### **电子计算机的实现：**

* **逻辑门：真空电子管**
* **存储器：延迟线**
* **输入/输出：打孔纸袋/指示灯（要不打一帧，要不挪一下）**

![](https://pan.udolphin.com/files/image/2022/6/d66dfc4e6cc24d9065ddc138b0872391.png)

![](https://pan.udolphin.com/files/image/2022/6/7bd9b9bd899ca9373c6f7d6f8cdd1ad6.png)

通过机械波，从左边进。需要用的时候通过放大器把它读出来。不是冯诺依曼结构。（可以计算平方表，求素数，微分和积分）。

**冯·诺伊曼**对世界上第一台电子计算机ENIAC（电子数字积分计算机）的设计提出过建议，1945年3月他在共同讨论的基础上起草了一个全新的“存储程序通用电子计算机方案”--[EDVAC](https://baike.baidu.com/item/EDVAC)（Electronic Discrete Variable Automatic Computer的缩写）。这对后来计算机的设计有决定性的影响，特别是**确定计算机的结构，采用存储程序以及二进制编码等**，至今仍为电子计算机设计者所遵循。

##### **冯诺依曼体系结构的特点：**

> (1)计算机处理的数据和指令一律用二进制数表示。
>
> (2)顺序执行程序。**计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序从主存储器中取出指令一条一条地执行**，这一概念称作顺序执行程序。
>
> (3)计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成。

## **1950s年计算机**

##### **硬件**

在1950s，贝尔实验室发明的晶体管、出现了磁芯、以及丰富的 I/O 设备。当时内存很小，仅有几KB。但相较 “埃尼阿克”，**我们有了更快更小的逻辑门，更大的内存，还有丰富的 I/O设备。**伴随着硬件的发展，I/O设备的速度已经严重低于处理器的速度，中断机制出现（1953）。

**图为1950S的内存，内存相当于一个二维数组，每块区域有一个可以指向两个不同方向的指针。指向的不同方向分别代表0和1。**

![](https://pan.udolphin.com/files/image/2022/6/f9e3b66d1b837af224264a0bd5952ff4.png)

图为1950S计算机

![](https://pan.udolphin.com/files/image/2022/6/80ec7c75330f34ce102e1f341aff1f98.png)

## **1950s程序**

**计算机可以执行更复杂的任务，通用的计算任务。希望使用计算机的人越来越多，希望调用API而不是直接访问设备。**

**Fortran诞生（1957）**

![](https://pan.udolphin.com/files/image/2022/6/2c3618d9b3f605080ab4a2151fcedafc.png)

（在1950s，如果想要写一行代码，就需要在一行代码上打孔。所以需要画流程图来编程。）

![](https://pan.udolphin.com/files/image/2022/6/337c198b37fe9ded7f2e925f3d9c01a7.png)

**于是我们有了管理多个程序依次排队运行的库函数和调度器（可以切换卡片的机器）。**

**调度器的产生主要有三点原因：**

> 写程序跑程序都是非常费事的（比如写一个死循环。。。）
>
> 计算机超级贵（$50,000 - $1,000,000），一个学校一台。
>
> 产生了集中管理计算机的需求，**多用户排队共享计算机**

##### **操作系统概念开始形成**

> **操作任务的系统（管理卡片的程序）**
>
> **批处理系统 = 程序的自定切换（换卡） + 库函数 API**
>
> **Disk Operating Systems (DOS) 1956年**

操作系统中开始出现“设备”，“文件”（计算结果写到卡片上），“任务”等对象和API

虽然听起来比较高效，实际操作就是，管理员前一天会把卡片都收好，规定好需要用的执行时间。收集后将卡片存放在一个地方，隔一段时间。推出当前执行卡片，换一张卡片继续执行。就有了可以**执行单一程序的操作系统。**

## **1960s的计算机**

1958年美国德州仪器的工程师Jack Kilby发明了集成电路（IC），总线出现。有了更快的处理器，更快、更大的内存，有了虚拟内存的出现。更丰富的I/O设备，完善的中断/异常机制。

**计算机可以同时载入多个程序而不用“换卡”了。**

## **1960s的程序**

有了更大的内存，可以同时存放好几个程序，很快的CPU（CPU不是一直都在计算）。**那么我们怎么提高它们的利用率呢？**

于是就有了进程切换，当一个程序A做 I/O 时，花一点时间让另一个程序B去计算。把A的状态保存到内存里，CPU去执行程序B。那时候有了现在我们知道的一些程序，可以执行多道程序。

##### **更多的高级语言和编译器出现**

**COBOL (1960). APL (1962). BASIC (1965)。Bill Gates 和Paul Allen 在 1975年实现了 Altair 8800 上的 BASIC解释器。计算机科学家们已经在今天难以想象的计算力下开发惊奇的程序。**

![](https://pan.udolphin.com/files/image/2022/7/946f90c00de133a4b8adfa9a72cdb322.png)

## **1960s的操作系统**

> 1960s的操作系统，能载入多个程序到内存且灵活调度它们的管理程序，包括程序可以调用的 APl。

同时将多个程序载入内存是一项巨大的能力。在1960s就有了**进程 (process) 的概念。**进程在执行 I/0时，可以将 CPU 让给另一个进程，可以在多个地址空间隔离的程序之间切换，虚拟存储使一个程序出bug 不会crash 整个系统。为了更好的管理程序，**操作系统中自然地增加进程管理 API。**

###### ![](https://pan.udolphin.com/files/image/2022/6/28c28dd4208b4e04203947ce7b91b346.png)

当A去执行 I/O 操作时，B 利用 CPU 进行运算。

##### **为什么要隔离地址空间呢？**

可能有人会有这样一个疑问，为什么我要利用虚拟存储隔离地址空间呢？

我们已知内存相当于一个二维数组。回到上面这张图，每个程序都有其对应的指令集，数据，临时存储数据的区域。如果执行一段程序，是不需要去管的，可以随便存储。但是如果执行两个程序，在程序切换时，两个程序是都在占用内存空间的。**如果执行程序A的数据出现了问题（结果没有写到了B对应临时存储区域），就会影响B的程序。**

![](https://pan.udolphin.com/files/image/2022/6/3cbcffd804e254a18c43f2fa98e10b62.png)

![](https://pan.udolphin.com/files/image/2022/6/d616080a85fea65cb535b1d8f35cb7a6.jpeg)

## 1970S的计算机

![](https://pan.udolphin.com/files/image/2022/6/a7884ddfc99e80261a8b592f2e5ff933.jpeg)

## **1970s的程序**

**PASCAL (1970), C (1972),..**

今天能办到的，那个时代已经都能办到了一一上天入地、图像声音视频、人工智能… 个人开发者 (Geek Network) 走上舞台。

**1979年也有了较早的文字处理程序（Wordstar）。**

![](https://pan.udolphin.com/files/image/2022/6/88a0efa7ba404e4d9f77f3a65608040e.webp)

## **1970s的操作系统**

> 分时系统走向成熟，UNIX 诞生并走向完善，奠定了现代操作系统的形态。

###### **1973:信号 API、管道(对象)、grep(应用程序）**

###### **1983: BSD socket（对象）**

###### **1984: procfs（对象）…**

###### **UNIX衍生出的大家族**

1BSD (1977), GNU (1983), MacOS (1984), AIX (1986), Minix  
(1987), Windows (1985), Linux 0.01 (1991), Windows NT (1993),  
Debian (1996), Windows XP (2002), Ubuntu (2004), iOS (2007),  
Android (2008), Windows 10 (2015), .....

## **今天的操作系统**

**现代计算机中的CPU的结构相当于增加了运算器的通用图灵机**。

![](https://pan.udolphin.com/files/image/2022/6/fc94ba986dee6f566dc7348fea71429e.png)

**区别**就在于通用图灵机把纸带作为唯一的存储部件，而CPU中出于效率的考虑，增加了许多**内部寄存器**以及**多个层次的存储缓存。**抛开这些可有可无的优化改造看，CPU的运行过程跟通用图灵机完全没有区别。

## 今天的操作系统

> 通过“虚拟化”硬件资源为程序运行提供服务的软件。

### **空前复杂的系统之一**

**•更复杂的处理器和内存**

• 非对称多处理器 (ARM big.LITTLE; Intel P/E-cores)

• Non-uniform Memory Access (NUMA)

•更多的硬件机制 Intel-VT/AMD-V, Trustzone/ SGX, TSX, .

**•更多的设备和资源**

•网卡、SSD、 GPU、 FPGA.

•复杂的应用需求和应用环境

•服务器、个人电脑、智能手机、手表、手环、loT/微控制器…

# **什么是程序**

前面我们了解了操作系统的历史。可以看到操作系统是随着硬件的提升，人们需求的增加，一步步演变过来的。最初是图灵机，到了庞大的计算机，后来可以多个程序执行。

##### **那么程序是什么？**

**一个程序由数据和指令构成，**是能让计算机执行的一段代码，是由010101占用的一块内存空间**。**我们常见的程序就是由 **C/JAVA/Python 语言写成的程序。**

## **从C语言的视角看**

**从C语言的视角，程序就是一条条语句。**

```bash
int main()
{
int a = 3, b = 4, c;
c = a + b;
}
```

## **从汇编/机器代码的视角**

从汇编/机器代码的视角，**程序就是指令集。(ARM64)**

```bash
000000000000000 <ltmp0>:
; {
0: ff 83 00 d1 sub sp, sp, #32
4: fd 7b 01 a9 stp x29, x30, [sp, #16]
8: fd 43 00 91 add x29, sp, #16
c: 68 00 80 52 mov w8, #3
; int a = 3, b = 4, c;
10: a8 c3 1f b8 stur w8, [x29, #-4]
14: 88 00 80 52 mov w8, #4
18: e8 0b 00 b9 str w8, [sp, #8]
; c = a + b;
1c: a8 c3 5f b8 ldur w8, [x29, #-4]
20: e9 0b 40 b9 ldr w9, [sp, #8]
24: 0a 01 09 0b add w10, w8, w9
28: 00 00 00 90 adrp x0, 0x0 <ltmp0+0x28>
2c: 00 00 00 91 add x0, x0, #0
; c = a + b;
30: e9 03 00 91 mov x9, sp
34: e8 03 0a aa mov x8, x10
38: 28 01 00 f9 str x8, [x9]
3c: 00 00 00 94 bl 0x3c <ltmp0+0x3c>
40: 00 00 80 52 mov w0, #0
; }
44: fd 7b 41 a9 ldp x29, x30, [sp, #16]
48: ff 83 00 91 add sp, sp, #32
4c: c0 03 5f d6 ret
```

**CPU想要调用一个程序时**，操作系统首先根据地址去内存里找对应的代码，如果找不到（缺页），继续去内存里进行查找。找到后将该地址后的4kb的代码读取到内存中（内存中存放的是可执行汇编指令）。

然后CPU申请一块内存空间（存放临时变量（堆栈）），读取数据，执行对应的指令。等到代码执行完成后，将申请内存空间释放。

> Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。

![](https://pan.udolphin.com/files/image/2022/6/5620542e61441b5fcd57d04b28219ac2.webp)

**注：**用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。所谓的**堆栈溢出**是指堆栈开辟的空间碰到了一起，重叠，说明空间不够了。

### **补充知识（CPU构成）**

![](https://pan.udolphin.com/files/image/2022/6/7fafe1e42eff1ff3391f95023c6652f3.png)

***数据段：***数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。**数据段属于静态内存分配。**

***代码段：***代码段（code segment/text segment）通常是指用来存放**程序执行代码**的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域**通常属于只读**, 某些架构也允许代码段为可写，即允许修改程序。**在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等**。

***堆**（heap）：*堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）

***栈**(stack)*：栈又称[堆栈](https://so.csdn.net/so/search?q=%E5%A0%86%E6%A0%88&spm=1001.2101.3001.7020)， 是用户存放程序临时创建的局部变量，也就是说我们**函数括弧“{}”中定义的变量**（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，**函数的返回值也会被存放回栈中**。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成**一个寄存、交换临时数据的内存区**。

## **从与操作系统交互的角度**

**从与操作系统交互的角度，程序就是系统调用（syscall）。**

**操作系统也是程序。**操作系统是计算机启动的第一个程序，与常见的程序不同的是，操作系统内部有一些集成了硬件的指令集。为程序提供了调用函数。

### **操作系统提供了哪些系统调用呢？**

##### **(1)进程控制类系统调用**

这类系统调用主要用于对进程的控制,如创建和终止进程的系统调用、获得和设置进程属性的系统调用等。

fork,ececve,exit - 进程的创建/改变/删除

##### **(2)文件操作类系统调用**

对文件进行操纵的系统调用数量较多,有创建文件、打开文件、关闭文件、读文件、写文件、创建一个目录、建立目录、移动文件的读/写指针、改变文件的属性等。

open,close,read,write - 文件访问管理

mkdir,link,unlink - 目录管理

##### **(3)进程通信类系统调用（虚拟内存管理）**

该类系统调用被用在进程之间传递消息和信号。

匿名管道(pipe)，命名管道([FIFO](https://so.csdn.net/so/search?q=FIFO&spm=1001.2101.3001.7020))，内存映射 虚拟地址空间管理(mapped memeory)，[消息队列](https://so.csdn.net/so/search?q=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020)(message queue)，共享内存(shared memory)，[信号量](https://so.csdn.net/so/search?q=%E4%BF%A1%E5%8F%B7%E9%87%8F&spm=1001.2101.3001.7020)(semaphore)，信号(signal)，[套接字](https://so.csdn.net/so/search?q=%E5%A5%97%E6%8E%A5%E5%AD%97&spm=1001.2101.3001.7020)(Socket)。

##### **(4)设备管理类系统调用**

该类系统调用被用于请求和释放有关设备,以及启动设备操作等

## **操作系统也是程序**

**操作系统是计算机启动之后执行第一个程序。**它也是中断处理程序，我们看到的所有东西都是第一个初始化程序创造的**子孙后代**。

![](https://pan.udolphin.com/files/image/2022/6/e272f30cc2646324a66c828921018ef5.png)

操作系统会加载“第一个程序”，创建了“树根”上的第一个进程。剩下所有进程都是由“树根”创建的。操作系统封装了一些系统硬件的调用，从而让人们更方便的去调用。程序利用各种各样的系统调用，复制进程，重置进程，销毁进程。

**这些计算机中已运行的程序被称为进程。它们是分配系统资源CPU时间、内存的实体。操作系统就是管理这些执行进程的软件。**

从任务管理器中，我们可以看到当前运行的一些程序，由此可以看出操作系统管理进程记录了哪些数据。例如：进程名称，创建时间，占用时间，创建线程数，PID 等。

![](https://pan.udolphin.com/files/image/2022/6/609b200730b235761ce0ee35153cb686.png)

##### **那么，在 Linux 中，又是怎样组织众多调度实体，进而组织众多进程，方便进程调度器找到调度实体呢？**

首先，Linux 定义了一个进程运行队列结构，每个 CPU 分配一个这样的进程运行队列结构实例变量，进程运行队列结构的代码如下。

![](https://pan.udolphin.com/files/image/2022/6/0f4a9e8c295552b39f077d2203a82b28.png)

以上这个 rq 结构结构中，很多我们不需要关注的字段已经省略了。

### **Linux 进程的数据结构**

Linux 系统下，把运行中的应用程序抽象成一个数据结构 task\_struct，一个应用程序所需要的各种资源，如内存、文件等都包含在 task\_struct 结构中。因此，task\_struct 结构是非常巨大的一个数据结构，代码如下。

![](https://pan.udolphin.com/files/image/2022/6/6f17734a493523e4797f8aec8e70c500.png)

### **调度实体和运行队列**

**![](https://pan.udolphin.com/files/image/2022/6/844121a4d971d0c208d32efa5c8f12cc.png)**

# 在计算机中执行一个程序发生了什么

以我们通常学习编程时的hello world 为例：

![](https://pan.udolphin.com/files/image/2022/6/cdf8e3dad9778eb5d46cf9cc1294df45.png)

操作系统它的主要硬件包括：IO（显示器，键盘，鼠标），磁盘，内存，CPU。

###### **各个硬件的作用：**

1\. 总线，负责连接各种其它设备，是其它设备工作的基础。

2.CPU，即中央处理器，负责执行程序和处理数据运算。

3\. 内存，负责储存运行时的代码和数据。

4\. 硬盘，负责长久储存用户文件数据。

5\. 网卡，负责计算机与计算机之间的通信。

6\. 显卡，负责显示工作。

7\. 各种 I/O 设备，如显示器，打印机，键盘，鼠标等。

###### **执行流程流程：**

\* 用户告诉操作系统执行hello程序

\* 操作系统到硬盘找到该程序

\* 由编译程序将用户源程序编译成若干个目标模块

\* 由链接程序将目标模块和相应的库函数链接成装入模块

\* 操作系统分配内存，由装入程序将编译好的二进制代码装入模块装入内存

\* 为执行hello程序创建执行环境（创建新进程）

\* 操作系统设置CPU上下文环境，并跳到程序开始处

\* 程序的第一条指令执行

\* 程序执行与printf对应的系统调用

\* 操作系统分配设备

\* 执行显示驱动程序

# 小结

本篇主要讲了什么是操作系统，计算机、操作系统的历史，什么是程序，操作系统也是程序。**事物的形成都有其必然性**，通过了解计算机，操作系统的历史可以更好的理解其发展。从1946年至今，计算机已经有70多年的历史，前人为计算机做了很多优化，结构越来复杂，硬件越来越多，I/O设备越来越多。

其实从图灵机到现在的计算机，**其根本结构并没发生变化**。**区别**就在于通用图灵机把纸带作为唯一的存储部件，而CPU中出于效率的考虑，增加了许多**内部寄存器**以及**多个层次的存储缓存。**抛开这些可有可无的优化改造看，CPU的运行过程跟通用图灵机完全没有区别。

从二进制到现在我们快速实现的代码，一层层封装抽象越来越易懂。**计算机在前人的积累上一点点发展至今**，甚至计算机中计算也是一点点累积起来的，其实计算机中只有加法操作，减法相当于加了一个负数，乘法相当于多个加法的叠加。除法相当于乘一个小数。

**理解计算机的结构，其发展历史，才能更好的去理解操作系统。**现在的操作系统的结构越来越复杂，做了很多优化，不过还是没有脱离已有的结构。了解操作系统，了解程序，其目的是为了更好的学习操作系统。（如果有描述不合理的地方，欢迎指正）