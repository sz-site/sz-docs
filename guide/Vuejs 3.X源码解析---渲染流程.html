<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前言 | 生椰拿铁</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="https://static.uino.cn/uino_favicon_32.ico">
    <meta name="description" content="sz docs">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/sz-docs/assets/css/0.styles.677476a9.css" as="style"><link rel="preload" href="/sz-docs/assets/js/app.5b32c35c.js" as="script"><link rel="preload" href="/sz-docs/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/sz-docs/assets/js/26.88d6c7f3.js" as="script"><link rel="prefetch" href="/sz-docs/assets/js/10.053ba524.js"><link rel="prefetch" href="/sz-docs/assets/js/11.1159667a.js"><link rel="prefetch" href="/sz-docs/assets/js/12.b7682a80.js"><link rel="prefetch" href="/sz-docs/assets/js/13.b40896ae.js"><link rel="prefetch" href="/sz-docs/assets/js/14.7d6cdd2a.js"><link rel="prefetch" href="/sz-docs/assets/js/15.96809982.js"><link rel="prefetch" href="/sz-docs/assets/js/16.9183fc9e.js"><link rel="prefetch" href="/sz-docs/assets/js/17.ecc2fb02.js"><link rel="prefetch" href="/sz-docs/assets/js/18.cbb699f8.js"><link rel="prefetch" href="/sz-docs/assets/js/19.be221f77.js"><link rel="prefetch" href="/sz-docs/assets/js/20.2607d007.js"><link rel="prefetch" href="/sz-docs/assets/js/21.88cceb8e.js"><link rel="prefetch" href="/sz-docs/assets/js/22.c2db27be.js"><link rel="prefetch" href="/sz-docs/assets/js/23.5ab628b9.js"><link rel="prefetch" href="/sz-docs/assets/js/24.c2cdaaf6.js"><link rel="prefetch" href="/sz-docs/assets/js/25.bb060f6b.js"><link rel="prefetch" href="/sz-docs/assets/js/27.ef250fa3.js"><link rel="prefetch" href="/sz-docs/assets/js/28.91b5a71e.js"><link rel="prefetch" href="/sz-docs/assets/js/29.745520d1.js"><link rel="prefetch" href="/sz-docs/assets/js/3.79377ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/30.13248181.js"><link rel="prefetch" href="/sz-docs/assets/js/31.faef1119.js"><link rel="prefetch" href="/sz-docs/assets/js/32.35b4c0f9.js"><link rel="prefetch" href="/sz-docs/assets/js/33.549cceab.js"><link rel="prefetch" href="/sz-docs/assets/js/34.8255ba0d.js"><link rel="prefetch" href="/sz-docs/assets/js/35.b405a383.js"><link rel="prefetch" href="/sz-docs/assets/js/36.5a2bf352.js"><link rel="prefetch" href="/sz-docs/assets/js/37.fade1781.js"><link rel="prefetch" href="/sz-docs/assets/js/38.c8d2ce07.js"><link rel="prefetch" href="/sz-docs/assets/js/39.376ae4ae.js"><link rel="prefetch" href="/sz-docs/assets/js/4.da3ef268.js"><link rel="prefetch" href="/sz-docs/assets/js/40.0acd063f.js"><link rel="prefetch" href="/sz-docs/assets/js/41.9f78abdc.js"><link rel="prefetch" href="/sz-docs/assets/js/42.6a89ac09.js"><link rel="prefetch" href="/sz-docs/assets/js/43.bc99f8ea.js"><link rel="prefetch" href="/sz-docs/assets/js/44.69b35b37.js"><link rel="prefetch" href="/sz-docs/assets/js/45.e2b2355f.js"><link rel="prefetch" href="/sz-docs/assets/js/46.effed0fc.js"><link rel="prefetch" href="/sz-docs/assets/js/47.e6a07c4f.js"><link rel="prefetch" href="/sz-docs/assets/js/48.2b8050ee.js"><link rel="prefetch" href="/sz-docs/assets/js/49.56faf412.js"><link rel="prefetch" href="/sz-docs/assets/js/5.dac787d8.js"><link rel="prefetch" href="/sz-docs/assets/js/50.9bf5d2ab.js"><link rel="prefetch" href="/sz-docs/assets/js/51.5dc46630.js"><link rel="prefetch" href="/sz-docs/assets/js/52.a912ec7d.js"><link rel="prefetch" href="/sz-docs/assets/js/53.67bb5c60.js"><link rel="prefetch" href="/sz-docs/assets/js/54.2c797ca7.js"><link rel="prefetch" href="/sz-docs/assets/js/55.3580bd84.js"><link rel="prefetch" href="/sz-docs/assets/js/56.5252541f.js"><link rel="prefetch" href="/sz-docs/assets/js/57.3f36d034.js"><link rel="prefetch" href="/sz-docs/assets/js/58.609e0a8b.js"><link rel="prefetch" href="/sz-docs/assets/js/59.b3529e96.js"><link rel="prefetch" href="/sz-docs/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/sz-docs/assets/js/60.d52adccd.js"><link rel="prefetch" href="/sz-docs/assets/js/61.990276f0.js"><link rel="prefetch" href="/sz-docs/assets/js/62.e42f2df7.js"><link rel="prefetch" href="/sz-docs/assets/js/63.34f79dc1.js"><link rel="prefetch" href="/sz-docs/assets/js/7.307492ca.js"><link rel="prefetch" href="/sz-docs/assets/js/8.2b132dc4.js"><link rel="prefetch" href="/sz-docs/assets/js/9.3c5a8fdb.js">
    <link rel="stylesheet" href="/sz-docs/assets/css/0.styles.677476a9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sz-docs/" class="home-link router-link-active"><!----> <span class="site-name">生椰拿铁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  文章
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  文章
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/sz-docs/guide/万字解析 - React Fiber架构.html" class="sidebar-link">第1期：万字解析 - React Fiber架构</a></li><li><a href="/sz-docs/guide/Svelte，未来十年可能取代React和Vue等其他框架的新兴技术.html" class="sidebar-link">第2期：未来之星 - Svelte</a></li><li><a href="/sz-docs/guide/一看就会 - Git篇.html" class="sidebar-link">第3期：一看就会 - Git篇</a></li><li><a href="/sz-docs/guide/意博趣深 - RxJS.html" class="sidebar-link">第4期：意博趣深 - RxJS</a></li><li><a href="/sz-docs/guide/一劳永逸 - CSS布局.html" class="sidebar-link">第5期（上）：一劳永逸 - CSS布局</a></li><li><a href="/sz-docs/guide/CSS前生今世.html" class="sidebar-link">第5期（下）：一劳永逸 - CSS前生今世</a></li><li><a href="/sz-docs/guide/降维打击-Webpack对我们的代码做了什么？.html" class="sidebar-link">第6期：降维打击-Webpack对我们的代码做了什么？</a></li><li><a href="/sz-docs/guide/轮播图篇.html" class="sidebar-link">第7期：相见恨晚 - 轮播图篇</a></li><li><a href="/sz-docs/guide/TypeScript上.html" class="sidebar-link">第8期（上）：通俗易懂 - TypeScript(上)</a></li><li><a href="/sz-docs/guide/TypeScript下.html" class="sidebar-link">第8期（下）：通俗易懂-TypeScript(下)</a></li><li><a href="/sz-docs/guide/从koa到oak.html" class="sidebar-link">第9期：谁主沉浮 - 从koa到oak</a></li><li><a href="/sz-docs/guide/数字空间 - 如何提供稳定可靠服务？.html" class="sidebar-link">第10期：数字空间 - 如何提供稳定可靠服务？</a></li><li><a href="/sz-docs/guide/序列比对-Smith–Waterman算法.html" class="sidebar-link">第11期（上）：序列比对-Smith–Waterman算法</a></li><li><a href="/sz-docs/guide/图布局算法-Sugiyama算法框架.html" class="sidebar-link">第11期（下）：图布局算法-Sugiyama算法框架</a></li><li><a href="/sz-docs/guide/数组进阶 - 数组学到什么样才算精通.html" class="sidebar-link">第12期（上）：数组进阶 - 数组学到什么样才算精通</a></li><li><a href="/sz-docs/guide/复杂度分析 - 这可能是你见过的最好的复杂度分析文章.html" class="sidebar-link">第12期（中）：复杂度分析 - 这可能是你见过的最好的复杂度分析文章</a></li><li><a href="/sz-docs/guide/散列表与二分查找.html" class="sidebar-link">第12期（下）：散列表与二分查找</a></li><li><a href="/sz-docs/guide/Promise漫谈.html" class="sidebar-link">第13期：一诺千金 - Promise漫谈</a></li><li><a href="/sz-docs/guide/编译原理 - 抽象语法树（Abstract Syntax Tree，AST）.html" class="sidebar-link">第14期：编译原理 - 抽象语法树（Abstract Syntax Tree，AST）</a></li><li><a href="/sz-docs/guide/如何写出健壮的CSS.html" class="sidebar-link">第15期（上）：得心应手 - 如何写出健壮的CSS</a></li><li><a href="/sz-docs/guide/CSS3的世界.html" class="sidebar-link">第15期（上）：得心应手 - CSS3的世界</a></li><li><a href="/sz-docs/guide/正则表达式.html" class="sidebar-link">第16期：如鱼得水 - 正则表达式</a></li><li><a href="/sz-docs/guide/由一道面试题想到的.html" class="sidebar-link">第17期：由一道面试题想到的</a></li><li><a href="/sz-docs/guide/浅谈移动端.html" class="sidebar-link">第18期：手机时代 - 浅谈移动端</a></li><li><a href="/sz-docs/guide/js设计模式思想之策略模式思想与发布订阅模式思想.html" class="sidebar-link">第19期： 代码重构 - 浅谈策略模式思想与发布-订阅模式思想</a></li><li><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html" class="sidebar-link">第20期：手写系列 - 简易webpack编译过程</a></li><li><a href="/sz-docs/guide/Vite pourquoi si vite.html" class="sidebar-link">第21期：Vite pourquoi si vite</a></li><li><a href="/sz-docs/guide/WebAssembly.html" class="sidebar-link">第22期：未来已来 - WebAssembly</a></li><li><a href="/sz-docs/guide/浅谈数据压缩.html" class="sidebar-link">第23期：浅谈数据压缩</a></li><li><a href="/sz-docs/guide/第二十四期：Apache POI Excel 和 EasyExcel——读写Excel.html" class="sidebar-link">第24期：Apache POI Excel 和 EasyExcel——读写Excel</a></li><li><a href="/sz-docs/guide/第二十五期：浅谈多线程.html" class="sidebar-link">第25期：浅谈多线程</a></li><li><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html" class="sidebar-link">第26期：霍夫曼编码-Huffman Coding</a></li><li><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html" class="sidebar-link">第27期：聚类基础-KMean和均值漂移聚类</a></li><li><a href="/sz-docs/guide/web性能优化.html" class="sidebar-link">第28期：web性能优化</a></li><li><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html" class="sidebar-link">第29期：分包吗 - Webpack</a></li><li><a href="/sz-docs/guide/TypeScript类型编程.html" class="sidebar-link">第30期：类型体操 - TypeScript类型编程</a></li><li><a href="/sz-docs/guide/Javasript设计模式之状态模式和代理模式.html" class="sidebar-link">第31期（上）：Javasript设计模式之状态模式和代理模式</a></li><li><a href="/sz-docs/guide/Javasript设计模式之工厂模式和装饰器模式.html" class="sidebar-link">第31期（下）：Javasript设计模式之工厂模式和装饰器模式</a></li><li><a href="/sz-docs/guide/ahooks-一套方便且实用的React Hooks库.html" class="sidebar-link">第32期：ahooks-一套方便且实用的React Hooks库</a></li><li><a href="/sz-docs/guide/Babel-通天塔.html" class="sidebar-link">第33期：Babel-通天塔</a></li><li><a href="/sz-docs/guide/Canvas.html" class="sidebar-link">第34期：Canvas-全集宝典</a></li><li><a href="/sz-docs/guide/WebSocket原理.html" class="sidebar-link">第35期：WebSocket原理</a></li><li><a href="/sz-docs/guide/操作系统——前言.html" class="sidebar-link">第36期：操作系统——前言</a></li><li><a href="/sz-docs/guide/WebSocket数据加密.html" class="sidebar-link"> 第37期：WebSocket数据加密</a></li><li><a href="/sz-docs/guide/Redis五种数据类型实现.html" class="sidebar-link">第38期：Redis五种数据类型实现</a></li><li><a href="/sz-docs/guide/操作系统——启动流程.html" class="sidebar-link">第39期：操作系统——启动流程</a></li><li><a href="/sz-docs/guide/Docker初识.html" class="sidebar-link">第40期：Docker初识</a></li><li><a href="/sz-docs/guide/webpack-runtime.html" class="sidebar-link">第41期：揭开WebpackRuntime的面纱</a></li><li><a href="/sz-docs/guide/grid layout.html" class="sidebar-link">第42期：前端布局大法之grid布局</a></li><li><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html" class="active sidebar-link">第43期：Vuejs 3.X源码解析---渲染流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#创建vnode" class="sidebar-link">创建vnode</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#createvnode" class="sidebar-link">createVNode</a></li></ul></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#渲染vnode" class="sidebar-link">渲染vnode</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#render" class="sidebar-link">render</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#patch" class="sidebar-link">patch</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#processcomponent" class="sidebar-link">processComponent</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#mountcomponent" class="sidebar-link">mountComponent</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#setupcomponent" class="sidebar-link">setupComponent</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#setupstatefulcomponent" class="sidebar-link">setupStatefulComponent</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#finishcomponentsetup" class="sidebar-link">finishComponentSetup</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#setuprendereffect" class="sidebar-link">setupRenderEffect</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#rendercomponentroot" class="sidebar-link">renderComponentRoot</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#processelement" class="sidebar-link">processElement</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#mountelement" class="sidebar-link">mountElement</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html#mountchildren" class="sidebar-link">mountChildren</a></li></ul></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h1> <p>一直都是React用的比较多，对于Vue3没有深入了解过，所以今天想从源码的角度深入了解一下。</p> <p>Vue.js 3.0 (以下简称Vue3)，正式发布在 2020 年 09 月 18 日</p> <ul><li>vue3源码地址：<a href="https://github.com/vuejs/core" target="_blank" rel="noopener noreferrer">https://github.com/vuejs/core<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p><img src="https://pic1.zhimg.com/v2-5f4e219c7356cf7f2efd5c07a22dd520_720w.jpg?source=172ae18b" alt="查看源图像"></p> <h1 id="源码目录"><a href="#源码目录" class="header-anchor">#</a> 源码目录</h1> <p>学习源码之前，我们首先对它的目录结构了解一下，在这里我们只重点关注package目录，整个结构如下：</p> <p><img src="https://pan.udolphin.com/files/image/2022/11/b1afaf64edfa84b772259bdb82a1debb.png" alt=""></p> <p>Vue3采用 monorepo 管理项目代码的方式。这些模块拆分到不同的package中，每个package有各自的API、类型定义和测试。这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确。</p> <ul><li>compiler-core: 与平台无关的编译模块，例如基础的 baseCompile 编译模版文件, baseParse生成AST</li> <li>compiler-dom: 基于compiler-core，专为浏览器的编译模块，可以看到它基于baseCompile，baseParse，重写了complie、parse</li> <li>compiler-sfc: 用来编译vue单文件组件</li> <li>compiler-ssr: 服务端渲染相关的</li> <li>reactivity: vue独立的响应式模块</li> <li>runtime-core: 也是与平台无关的基础模块，有vue的各类API，虚拟dom的渲染器</li> <li>runtime-dom: 基于runtime-core，针对浏览器的运行时</li> <li>vue: 引入导出 runtime-core，还有编译方法</li></ul> <p>除掉服务端渲染相关代码、开发调试、测试相关代码，我们可以看到package中重要的模块有5个将它们的依赖关系体现出来，则大致是这样的</p> <p><img src="https://pan.udolphin.com/files/image/2022/11/4ad786efc8ecc58eb5863bf8fa98c05a.png" alt=""></p> <p>我们从模块关系图中可以看到Vuejs3有两个阶段：编译时和运行时。</p> <p><strong>编译时</strong></p> <p>我们平常开发时写的.vue文件是无法直接运行在浏览器中的，所以在<strong>编译阶段</strong>，需要将.vue文件编译生成对应的js代码，vue组件对应的template模板会被<strong>编译器</strong>转化为render函数。</p> <p><strong>运行时</strong></p> <p>接下来，当编译后的代码真正运行在浏览器时，便会<strong>执行render函数</strong>并返回VNode，也就是所谓的虚拟DOM，最后将VNode渲染成真实的DOM节点。</p> <blockquote><p><strong>思考</strong>： vue文件是如何转换成DOM节点，并渲染到浏览器上的？</p></blockquote> <p>了解完Vue组件渲染的思路后，接下来让我们从源码的角度深入了解一下<strong>Vue组件的整个渲染流程</strong>是怎么样的？</p> <h1 id="createapp入口"><a href="#createapp入口" class="header-anchor">#</a> createApp入口</h1> <p>在Vue3中，每个Vue应用都是通过createApp函数创建一个新的应用实例开始的：</p> <div class="language- extra-class"><pre class="language-text"><code>import { createApp } from 'vue'
import App from './App.vue'
 
createApp(App).mount('#app') 
</code></pre></div><p>这里的App是根组件，作为渲染组件的起点</p> <p>mount('#app') 表示要被挂载的DOM节点</p> <p>由此可见，初始化渲染共分为两步：</p> <p>1、创建app</p> <p>2、挂载app</p> <div class="language- extra-class"><pre class="language-text"><code>export const createApp = ((...args) =&gt; {
  // 第一步：创建了app实例
  const app = ensureRenderer().createApp(...args)
  // 第二步：重写了app.mount方法
  const { mount } = app
  app.mount = (containerOrSelector: Element | ShadowRoot | string): any =&gt; {
    ...
  }
  //第三步：返回app实例
  return app
})
</code></pre></div><h1 id="创建app"><a href="#创建app" class="header-anchor">#</a> 创建app</h1> <h3 id="ensurerenderer"><a href="#ensurerenderer" class="header-anchor">#</a> ensureRenderer</h3> <p>首先通过<code>ensureRenderer</code>创建web端的渲染器</p> <div class="language- extra-class"><pre class="language-text"><code>// 渲染时使用的一些配置方法，如果在浏览器环境就是会传入很多 DOM API
let rendererOptions = {
  patchProp,
  forcePatchProp,
  insert,
  remove,
  createElement,
  cloneNode,
  ...
}
// lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.
let renderer

function ensureRenderer () {
  return renderer || (renderer = createRenderer(rendererOptions))
}
</code></pre></div><h3 id="createrenderer-basecreaterenderer"><a href="#createrenderer-basecreaterenderer" class="header-anchor">#</a> createRenderer&amp;baseCreateRenderer</h3> <p>接下来进入<code>createRenderer</code>方法，会返回一个<code>baseCreateRenderer</code>方法。这里是为了跨平台做准备的，可以根据不同的平台传入不同的 <code>options</code>去生成不同的渲染器。 在最后<code>baseCreateRenderer</code>会返回一个<code>render</code>方法和最终的<code>createApp</code>(也就是<code>createAppAPI</code>) 方法。</p> <div class="language- extra-class"><pre class="language-text"><code>export function createRenderer&lt; HostNode = RendererNode, HostElement = RendererElement&gt;(options: RendererOptions&lt;HostNode, HostElement&gt;) {
  return baseCreateRenderer&lt;HostNode, HostElement&gt;(options)
}

function baseCreateRenderer(
  options: RendererOptions,  //跨平台设计，不同平台传入不同的options
  createHydrationFns?: typeof createHydrationFunctions
) {
  
  // 第一步：各平台传入的options中的API方法 重新统一命名
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    ...
  } = options
 
  // 第二步：定义各种渲染需要的方法
  const patch = (n1, n2,container...)=&gt;{...}
  const render = (vnode, container, isSVG) =&gt; {...}
  const mountComponent = (initialVNode, container...) =&gt; {...}
  ....
  
  // 第三步：返回一个含有 {render, hydrate, createApp} 属性的对象
  return {
    render,
    hydrate,//服务器端渲染相关
    createApp: createAppAPI(render, hydrate)
  }
}
</code></pre></div><h3 id="createappapi"><a href="#createappapi" class="header-anchor">#</a> createAppAPI</h3> <p><code>createAppAPI</code> 方法通过闭包返回createApp方法，并把render方法保留下来供内部使用，接受了 rootComponent 和 rootProps 两个参数，我们在应用层面执行 <code>createApp(App)</code> 方法时，会把 App 组件对象作为根组件传递给 rootComponent。这样，createApp 内部就创建了一个 app 对象，它会提供 mount 方法，这个方法是用来挂载组件的。</p> <div class="language- extra-class"><pre class="language-text"><code> export function createAppAPI&lt;HostElement&gt;(
 render: RootRenderFunction,  // 在baseCreateRenderer中传入的render
  hydrate?: RootHydrateFunction
){  
  // 真正创建app的入口
  return function createApp(rootComponent, rootProps = null) {
    if (rootProps != null &amp;&amp; !isObject(rootProps)) {
      __DEV__ &amp;&amp; warn(`root props passed to app.mount() must be an object.`)
      rootProps = null
    }
    // 创建vue应用上下文
    const context = createAppContext()
    const installedPlugins = new Set()
 
    let isMounted = false
    // 创建了app实例，并返回
    const app: App = (context.app = {
      _uid: uid++,
      _component: rootComponent as ConcreteComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      version,
      get config() {return context.config},
      set config(v) {},
 
      use(plugin: Plugin, ...options: any[]) {...},
      mixin(mixin: ComponentOptions) {...},
      component(name: string, component?: Component): any {...},
      directive(name: string, directive?: Directive) {...},
      mount(rootContainer: HostElement,isHydrate?: boolean,isSVG?: boolean): any {...},
      unmount() {...},
      provide(key, value) {...}
    })
    //返回app
    return app
  }
}
</code></pre></div><p>到这里为止，我们的 app 实例就创建好了。我们可以看出来，vue3 的设计方式是将平台相关的操作抽离出去，这样对多平台框架开发者及其友好，只需要关注对应平台的节点操作，创建渲染器即可。</p> <h1 id="重写app-mount方法"><a href="#重写app-mount方法" class="header-anchor">#</a> 重写app.mount方法</h1> <p>我们回到入口，获取到app实例后，vue把实例中的mount方法缓存一下，并且重写mount方法。<strong>为什么要重写mount方法呢？</strong><code>为了支持跨平台渲染</code>，不同平台具有不同的渲染器，不同渲染器中会调用标准的baseCreateRenderer来保证核心的渲染流程是一致的。而createApp函数内部的<code>app.mount方法是标准的可跨平台的组件渲染流程</code>。所以在这段代码中不应该包含特定平台相关的逻辑，因此需要在外部重写这个方法，来完善Web平台下的渲染逻辑。</p> <div class="language- extra-class"><pre class="language-text"><code>export const createApp = ((...args) =&gt; {
   ...
  // 缓存已有的mount方法
  const { mount } = app
  // 重写mount
  app.mount = (containerOrSelector: Element | ShadowRoot | string): any =&gt; {
    // 处理containerOrSelector，获取真实的DOM元素
    const container = normalizeContainer(containerOrSelector)
    if (!container) return
    
    // 获取定义的 Vue app 对象, 之前的 rootComponent
    const component = app._component
    // 如果不是函数、没有 render 方法、没有 template 使用 DOM 元素内的 innerHTML 作为内容
    if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) {
      component.template = container.innerHTML
    }
    
    // 挂载之前清空内容
    container.innerHTML = ''
    // 真正的挂载，调用上面缓存原定义的mount方法
    const proxy = mount(container, false, container instanceof SVGElement)
    if (container instanceof Element) {
      container.removeAttribute('v-cloak')
      container.setAttribute('data-v-app', '')
    }
    return proxy
  }
  return app
 }
</code></pre></div><h3 id="createappapi-中的mount"><a href="#createappapi-中的mount" class="header-anchor">#</a> createAppAPI 中的mount</h3> <p>在上面createAppAPI创建app实例方法中，定义了mount：</p> <p>mount方法内部的流程也比较清晰，首先是创建vnode，之后是渲染vnode，并将其挂载到rootContainer上。</p> <div class="language- extra-class"><pre class="language-text"><code>function createAppAPI(render, hydrate) {
  // 真正创建app的入口
  return function createApp(rootComponent, rootProps = null) {
    // ...
    const app = (context.app = {
      // 挂载根组件
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          // 创建根组件对应的vnode
          const vnode = createVNode(rootComponent, rootProps);
          // 根级vnode存在应用上下文
          vnode.appContext = context;
          if (isHydrate &amp;&amp; hydrate) {  // 服务端渲染相关
            hydrate(vnode as VNode&lt;Node, Element&gt;, rootContainer as any)
          } else {
          // 将虚拟vnode节点渲染成真实节点，并挂载
            render(vnode, rootContainer, isSVG)
          }
          isMounted = true;
          // 记录应用的根组件容器
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          app._instance = vnode.component;
          return vnode.component.proxy;
        }
      }
    });
    return app;
  };
}
</code></pre></div><p>到目前为止可以做一个小的总结:</p> <p><img src="https://pan.udolphin.com/files/image/2022/11/dca4f08dc3b7264bd4d78f079651e141.png" alt=""></p> <p>接下来就是创建vnode和渲染vnode</p> <h2 id="创建vnode"><a href="#创建vnode" class="header-anchor">#</a> 创建vnode</h2> <p>vnode 本质上是 JavaScript 对象，用来描述各个节点的信息。例如当前节点的类型，当前节点的class,style等属性以及子元素的节点信息。</p> <h3 id="createvnode"><a href="#createvnode" class="header-anchor">#</a> createVNode</h3> <p>createVNode方法就是创建一个对象并初始化各个属性。</p> <div class="language- extra-class"><pre class="language-text"><code>function createVNode(type, props, children) {
  // ...
  // class &amp; style normalization
  if (props) {
    let { class: klass, style }= props 
    props.class = normalizeClass(klass)
    props.style = normalizeStyle(style)
  }
  
  // vnode 类型
  const shapeFlag =isString(type)
    ? ShapeFlags.ELEMENTc
    : __FEATURE_SUSPENSE__ &amp;&amp; isSuspense(type)
      ? ShapeFlags.SUSPENSE
      : isTeleport(type)
        ? ShapeFlags.TELEPORT
        : isObject(type)
          ? ShapeFlags.STATEFUL_COMPONENT
          : isFunction(type)
            ? ShapeFlags.FUNCTIONAL_COMPONENT
            : 0 
    const vnode: VNode = {
      __v_isVNode: true,
      [ReactiveFlags.SKIP]: true,
      type,
      props,
      key: props &amp;&amp; normalizeKey(props),
      ref: props &amp;&amp; normalizeRef(props),
      scopeId: currentScopeId,
      children: null,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null
    }
    // 处理 children 子节点
    normalizeChildren(vnode, children)    
}
</code></pre></div><p><strong>shapeFlag属性</strong>是vnode在patch阶段过程中用到的信息标识，它主要用来定义描述组件的分类，依据不同的组件类型执行对应的处理逻辑。使用二进制的方式描述了组件的类型。</p> <div class="language- extra-class"><pre class="language-text"><code> export const enum ShapeFlags {
  ELEMENT = 1, // 表示一个普通的HTML元素
  FUNCTIONAL_COMPONENT = 1 &lt;&lt; 1, // 函数式组件
  STATEFUL_COMPONENT = 1 &lt;&lt; 2,  // 有状态组件
  TEXT_CHILDREN = 1 &lt;&lt; 3, // 子节点是文本
  ARRAY_CHILDREN = 1 &lt;&lt; 4, // 子节点是数组
  SLOTS_CHILDREN = 1 &lt;&lt; 5, // 子节点是插槽
  TELEPORT = 1 &lt;&lt; 6, // 表示vnode描述的是个teleport组件
  SUSPENSE = 1 &lt;&lt; 7, // 表示vnode描述的是个suspense组件
  COMPONENT_SHOULD_KEEP_ALIVE = 1 &lt;&lt; 8, // 表示需要被keep-live的有状态组件
  COMPONENT_KEPT_ALIVE = 1 &lt;&lt; 9, // 已经被keep-live的有状态组件
  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT 
  // 组件，有状态组件和函数式组件的统称
}
</code></pre></div><h2 id="渲染vnode"><a href="#渲染vnode" class="header-anchor">#</a> 渲染vnode</h2> <h3 id="render"><a href="#render" class="header-anchor">#</a> render</h3> <p>通过createVNode获取到根组件对应的vnode，然后执行render方法。</p> <div class="language- extra-class"><pre class="language-text"><code>// 实际调用的render方法即为baseCreateRenderer方法中缓存的render方法
function baseCreateRenderer() {
  const render = (vnode, container) =&gt; {
    if (vnode == null) {
      if (container._vnode) {
        // 卸载组件
        unmount()
      }
    } else {
      // 正常挂载
      patch(container._vnode || null, vnode, container)
    }
    container._vnode = vnode
  }
}
</code></pre></div><ul><li>当传入的vnode为null&amp;存在老的vnode，则进行卸载组件</li> <li>否则，正常挂载</li></ul> <h3 id="patch"><a href="#patch" class="header-anchor">#</a> patch</h3> <p>接下来，我们来看下render过程中的patch函数的实现：</p> <div class="language- extra-class"><pre class="language-text"><code>const patch: PatchFn = (
    n1, // 老 VNODE
    n2, // 新 VNODE
    container, // 挂载的节点
    anchor = null,
    parentComponent = null,
    parentSuspense = null,
    isSVG = false,
    slotScopeIds = null,
    optimized = false
  ) =&gt; {
    // 如果 老节点存在  并且 n1 n2 的类型不同
    // 卸载 老vnode
    if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1)
      unmount(n1, parentComponent, parentSuspense, true)
      n1 = null
    }

    // 从 新vnode 中获取 type , ref , shapeFlag
去匹配
    const { type, ref, shapeFlag } = n2
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor)
        break
      case Comment:
        processCommentNode(n1, n2, container, anchor)
        break
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG)
        } else if (__DEV__) {
          patchStaticNode(n1, n2, container, isSVG)
        }
        break
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        )
        break
      default:
        if (shapeFlag &amp; ShapeFlags.ELEMENT) {
          // match element
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          )
        } else if (shapeFlag &amp; ShapeFlags.COMPONENT) {
          // match component
          // 此时的 shapeFlag 会进入这个条件
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          )
        } else if (shapeFlag &amp; ShapeFlags.TELEPORT) {
          // match teleport
          ...
        } else if (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) {
          // match suspense
         ...
        }
    }

   ...
  }
</code></pre></div><p>可以看到, patch 方法核心目标就是 比较 新老 vnode 节点 并对其进行差异的操作. 在初始化渲染时 , 会先 patch 我们的根组件 . 于是会走到 processComponent 这个逻辑分支, 看一下他具体的实现</p> <h3 id="processcomponent"><a href="#processcomponent" class="header-anchor">#</a> processComponent</h3> <p>处理 component</p> <div class="language- extra-class"><pre class="language-text"><code>const processComponent = (
  n1: VNode | null,
  n2: VNode,
  container: RendererElement,
  anchor: RendererNode | null,
  parentComponent: ComponentInternalInstance | null,
  parentSuspense: SuspenseBoundary | null,
  isSVG: boolean,
  slotScopeIds: string[] | null,
  optimized: boolean
) =&gt; {
  n2.slotScopeIds = slotScopeIds
  // 如果 老vnode 是空的
  if (n1 == null) {
    // 如果 新vnode 是 KEPT_ALIVE
    if (n2.shapeFlag &amp; ShapeFlags.COMPONENT_KEPT_ALIVE) {
      // more
    } else {
      // 挂载节点
      mountComponent(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        optimized
      )
    }
  }
  else {
   // 对比更新
    updateComponent(n1, n2, optimized)
  }
}
</code></pre></div><h3 id="mountcomponent"><a href="#mountcomponent" class="header-anchor">#</a> mountComponent</h3> <p>我们编写的一个个component,在HTML中是不存在标签的，所以Vue需要为每一个组件创建实例并去构建组件间的关系。那么拿到一个组件vnode挂载时。首先就是要创建当前组件的实例。然后对创建好的实例进行设置。</p> <div class="language- extra-class"><pre class="language-text"><code>const mountComponent: MountComponentFn = (
    initialVNode, // 初始化的 vnode
    container, // 挂载目标
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    optimized
  ) =&gt; {
    // 创建组件实例
    // createComponentInstance 初始化一个组件实例模型
    const compatMountInstance =
      __COMPAT__ &amp;&amp; initialVNode.isCompatRoot &amp;&amp; initialVNode.component
    // 这个时候就把组件实例挂载到了组件vnode的component属性上了
    const instance: ComponentInternalInstance =
      compatMountInstance ||
      (initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      ))


    // 处理 prop slot 和 setup
    // 设置组件实例
    if (!(__COMPAT__ &amp;&amp; compatMountInstance)) {
      setupComponent(instance)
    }


    // 设置并运行带有副作用的渲染函数
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    )
  }
</code></pre></div><h3 id="setupcomponent"><a href="#setupcomponent" class="header-anchor">#</a> setupComponent</h3> <p>调用setupComponent方法后会对如prop,slots,生命周期函数等进行初始化</p> <div class="language- extra-class"><pre class="language-text"><code>export function isStatefulComponent(instance: ComponentInternalInstance) {
  return instance.vnode.shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT
}

export let isInSSRComponentSetup = false

export function setupComponent(
  instance: ComponentInternalInstance,
  isSSR = false
) {
  isInSSRComponentSetup = isSSR

  const { props, children } = instance.vnode
  //是否有状态组件，非函数式组件
  const isStateful = isStatefulComponent(instance)
  //初始化props和slots
  initProps(instance, props, isStateful, isSSR)
  initSlots(instance, children)
  //如果组件有状态，挂载setup信息
  const setupResult = isStateful
    ? setupStatefulComponent(instance, isSSR)
    : undefined
  isInSSRComponentSetup = false
  return setupResult
}
</code></pre></div><p>setupComponent会返回一个setupResult=setupStatefulComponent的返回值， 就是用户配置setup函数中return的值</p> <h3 id="setupstatefulcomponent"><a href="#setupstatefulcomponent" class="header-anchor">#</a> setupStatefulComponent</h3> <p>开始处理注册的 setup</p> <div class="language- extra-class"><pre class="language-text"><code>function setupStatefulComponent(
  instance: ComponentInternalInstance,
  isSSR: boolean
) {
   ...

  // 给实例添加一个缓存对象
  instance.accessCache = Object.create(null)
  // 创建渲染上下文代理
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))
  // 调用 setup 获得return的东西
  const { setup } = Component
  // 判断组件是否存在setup
  if (setup) {
    ...
  } else {
    finishComponentSetup(instance, isSSR)
  }
}
</code></pre></div><h3 id="finishcomponentsetup"><a href="#finishcomponentsetup" class="header-anchor">#</a> finishComponentSetup</h3> <p>获取 render function &amp;&amp; 兼容 vue2.x optionAPI</p> <p>设置组件实例的render方法:</p> <ul><li>若组件存在render方法，则instance.render = component.render</li> <li>若组件存在template模板，则instance.render = compile(template）</li></ul> <div class="language- extra-class"><pre class="language-text"><code>export function finishComponentSetup(
  instance: ComponentInternalInstance,
  isSSR: boolean,
  skipOptions?: boolean
) {
  ...


  // 如果实例没有 render 函数
   if (!instance.render) {
    // 检查 用户如果没在 其他位置注册 render function
    if (compile &amp;&amp; !Component.render) {
      // 拿到 Component.template
      // 即容器下的 innerHTML
      const template =
        (__COMPAT__ &amp;&amp;
          instance.vnode.props &amp;&amp;
          instance.vnode.props['inline-template']) ||
        Component.template

      if (template) {
        ...
        // 执行 compile 方法 
        // 获得 render function 挂载在component上
        Component.render = compile(template, finalCompilerOptions)
      }
    }
    // 拿到 render function 之后
    // 给 整个实例挂载 render
    instance.render = (Component.render || NOOP) as InternalRenderFunction
  }

  // 开始兼容 2.x的API
  // 所以 setup 解析完成才开始兼容2.x的API
  // support for 2.x options
  if (__FEATURE_OPTIONS_API__ &amp;&amp; !(__COMPAT__ &amp;&amp; skipOptions)) {
    currentInstance = instance
    applyOptions(instance)
    currentInstance = null
  }
}
</code></pre></div><p>当我们执行完这个方法后, 我们回到 mountComponent 这个方法. 他执行了 setupRenderEffect</p> <h3 id="setuprendereffect"><a href="#setuprendereffect" class="header-anchor">#</a> setupRenderEffect</h3> <p>核心方法 , 依赖收集 , 初始化渲染 , 后续的更新 , 都是通过这个方法进行的 。</p> <div class="language- extra-class"><pre class="language-text"><code>const setupRenderEffect = (instance, initialVNode, container, ...) =&gt; {
  // 创建响应式的副作用函数
  const componentUpdateFn = () =&gt; {
    // 首次渲染
    if (!instance.isMounted) {
      // 渲染组件生成子树vnode
      const subTree = (instance.subTree = renderComponentRoot(instance));
      patch(null, subTree, container, ...);
      initialVNode.el = subTree.el;
      instance.isMounted = true;
    }
    else {
      // 更新
    }
  };
 	// 创建渲染effcet
  const effect = new ReactiveEffect(
    componentUpdateFn, 
    () =&gt; queueJob(instance.update), 
    instance.scope // track it in component's effect scope
 	);
  const update = (instance.update = effect.run.bind(effect));
  update.id = instance.uid;
  update();
};
</code></pre></div><p>首先会创建渲染effect,并绑定副作用执行函数到组件实例的update属性上（更新流程会再次触发update函数），并立即执行update函数，触发首次更新。</p> <h3 id="rendercomponentroot"><a href="#rendercomponentroot" class="header-anchor">#</a> renderComponentRoot</h3> <p>构建 subTree</p> <p>所有的 template 模板最终都会被编译成渲染函数。</p> <p>而 renderComponentRoot 所做的工作就是<code>去执行编译后的渲染函数，最终得到的 subTree</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>export function renderComponentRoot(
  instance: ComponentInternalInstance
): VNode {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit,
    render, // 通过 compile 获取的 render function
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance
  let result
  try {
    let fallthroughAttrs
    if (vnode.shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT) {
      // 这里调用了render
      // 调用之后我们会拿到容器下节点的vnode tree
      // 之后校验 vnode tree 是否是合法的 vnode
      // 如果拿到的是合法的 vnode 就赋值给 result

      result = normalizeVNode(
        render!.call(
          proxyToUse,
          proxyToUse!,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      )
      fallthroughAttrs = attrs
    } else {
      // 如果是无状态组件
       ...
    }
    let root = result
    ...
   
  } catch (err) {
    blockStack.length = 0
    handleError(err, instance, ErrorCodes.RENDER_FUNCTION)
    result = createVNode(Comment)
  }
  return result
}
</code></pre></div><p>可以看到这个方法把我们容器下的所有节点变成了 vnode .验证完 vnode 的合法性之后, 会合并和继承一些属性. 最终把 vnode 返回.</p> <p>生成subtree后，接下来就继续通过patch方法，把subTree节点挂载到container上。我们又回到了 patch 方法.</p> <div class="language- extra-class"><pre class="language-text"><code>const patch: PatchFn = (
    n1, // null
    n2, // subTree
    container, // 挂载的节点
    anchor = null,
    parentComponent = null,
    parentSuspense = null,
    isSVG = false,
    slotScopeIds = null,
    optimized = false
  ) =&gt; {
    ...
    // shapeFlag 依然是组件类型标记
    const { type, ref, shapeFlag } = n2
    switch (type) {
      case Text:
        ...
        break
      case Comment:
         ...
        break
      case Static:
        ...
        break
      case Fragment:
        ...
        break
      default:
        if (shapeFlag &amp; ShapeFlags.ELEMENT) {
          // 此时我们会进入这个条件
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          )
        } else if (shapeFlag &amp; ShapeFlags.COMPONENT) {
          ...
        } else if (shapeFlag &amp; ShapeFlags.TELEPORT) {
         ...
        } else if (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) {
          ...
        }
    }
 
  }
</code></pre></div><p>以上就是component类型的vnode节点首次渲染挂载的流程，接下来我们来看看对于element类型的vnode节点又有什么不一样</p> <h3 id="processelement"><a href="#processelement" class="header-anchor">#</a> processElement</h3> <p>处理 element</p> <div class="language- extra-class"><pre class="language-text"><code>const processElement = (
    n1: VNode | null,
    n2: VNode,
    container: RendererElement,
    anchor: RendererNode | null,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    slotScopeIds: string[] | null,
    optimized: boolean
  ) =&gt; {
    isSVG = isSVG || (n2.type as string) === 'svg'
    // 老节点不存在 直接挂载
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      )
    }
    // 存在 对比更新
    else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      )
    }
</code></pre></div><h3 id="mountelement"><a href="#mountelement" class="header-anchor">#</a> mountElement</h3> <p>处理子元素 插入到目标节点</p> <div class="language- extra-class"><pre class="language-text"><code>const mountElement = (
    vnode: VNode,
    container: RendererElement,
    anchor: RendererNode | null,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    slotScopeIds: string[] | null,
    optimized: boolean
  ) =&gt; {
    let el: RendererElement
    let vnodeHook: VNodeHook | undefined | null
    const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode
    ...
    // 调用 hostCreateElement 创建真实 DOM
    el = vnode.el = hostCreateElement(
      vnode.type as string,
      isSVG,
      props &amp;&amp; props.is,
      props
    )
    // 子节点如果是 文本
    if (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) {
      // 操作 dom 赋值 text
      hostSetElementText(el, vnode.children as string)
    }
    // 子节点如果是 数组
    else if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) {
      // 挂载子节点
      mountChildren(
        vnode.children as VNodeArrayChildren,
        el,
        null,
        parentComponent,
        parentSuspense,
        isSVG &amp;&amp; type !== 'foreignObject',
        slotScopeIds,
        optimized || !!vnode.dynamicChildren
      )
    }

    // 如果当前元素有 props
    if (props) {
      // 遍历 props
      for (const key in props) {
        if (!isReservedProp(key)) {
          // 对props进行处理
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            isSVG,
            vnode.children as VNode[],
            parentComponent,
            parentSuspense,
            unmountChildren
          )
        }
      }
    }
    // 将当前操作节点 插入到对应容器下
    hostInsert(el, container, anchor)
  }
</code></pre></div><h3 id="mountchildren"><a href="#mountchildren" class="header-anchor">#</a> mountChildren</h3> <p>挂载子节点</p> <p>对 children 数组进行深度优先遍历，递归的调用 patch 方法依次将子节点 child 挂载到父节点上</p> <div class="language- extra-class"><pre class="language-text"><code>const mountChildren: MountChildrenFn = (
    children,
    container,
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    slotScopeIds,
    optimized,
    start = 0
  ) =&gt; {
    for (let i = start; i &lt; children.length; i++) {
      const child = (children[i] = optimized
        ? cloneIfMounted(children[i] as VNode)
        : normalizeVNode(children[i]))
      // 递归 patch 子元素
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      )
    }
  }
</code></pre></div><p>由于是递归，所以先分析的节点后被挂载，当最外层节点被挂载时，所有的节点就都被挂载了。</p> <p><img src="https://pan.udolphin.com/files/image/2022/11/35b0ccf38f089ca96c7a4238c20ff09e.png" alt=""></p> <h1 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h1> <ul><li>从组件到渲染生成 DOM 需要经历 3 个过程：创建 vnode - 渲染 vnode - 生成 DOM。</li> <li>组件是如何转变为 DOM 的：先把组件转化为 vnode，针对特定类型的 vnode 执行不同的渲染逻辑，最终调用 document 上的方法将 vnode 渲染成 DOM。</li> <li>渲染器是一个包含了平台渲染核心逻辑的 JavaScript 对象，可以用于跨平台渲染。</li> <li>渲染器对象中的 createApp 方法，创建了一个具有 mount 方法的 app 实例。app.mount 方法中先是用根组件创建了 vnode，然后调用渲染器对象中的 render 方法去渲染 vnode，最终通过 DOM API 将 vnode 转化为 DOM。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/sz-docs/guide/grid layout.html" class="prev">
        第42期：前端布局大法之grid布局
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/sz-docs/assets/js/app.5b32c35c.js" defer></script><script src="/sz-docs/assets/js/2.733019b2.js" defer></script><script src="/sz-docs/assets/js/26.88d6c7f3.js" defer></script>
  </body>
</html>
