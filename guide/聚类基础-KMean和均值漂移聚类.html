<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>聚类 | 生椰拿铁</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="https://static.uino.cn/uino_favicon_32.ico">
    <meta name="description" content="sz docs">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/sz-docs/assets/css/0.styles.677476a9.css" as="style"><link rel="preload" href="/sz-docs/assets/js/app.5b32c35c.js" as="script"><link rel="preload" href="/sz-docs/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/sz-docs/assets/js/59.b3529e96.js" as="script"><link rel="prefetch" href="/sz-docs/assets/js/10.053ba524.js"><link rel="prefetch" href="/sz-docs/assets/js/11.1159667a.js"><link rel="prefetch" href="/sz-docs/assets/js/12.b7682a80.js"><link rel="prefetch" href="/sz-docs/assets/js/13.b40896ae.js"><link rel="prefetch" href="/sz-docs/assets/js/14.7d6cdd2a.js"><link rel="prefetch" href="/sz-docs/assets/js/15.96809982.js"><link rel="prefetch" href="/sz-docs/assets/js/16.9183fc9e.js"><link rel="prefetch" href="/sz-docs/assets/js/17.ecc2fb02.js"><link rel="prefetch" href="/sz-docs/assets/js/18.cbb699f8.js"><link rel="prefetch" href="/sz-docs/assets/js/19.be221f77.js"><link rel="prefetch" href="/sz-docs/assets/js/20.2607d007.js"><link rel="prefetch" href="/sz-docs/assets/js/21.88cceb8e.js"><link rel="prefetch" href="/sz-docs/assets/js/22.c2db27be.js"><link rel="prefetch" href="/sz-docs/assets/js/23.5ab628b9.js"><link rel="prefetch" href="/sz-docs/assets/js/24.c2cdaaf6.js"><link rel="prefetch" href="/sz-docs/assets/js/25.bb060f6b.js"><link rel="prefetch" href="/sz-docs/assets/js/26.88d6c7f3.js"><link rel="prefetch" href="/sz-docs/assets/js/27.ef250fa3.js"><link rel="prefetch" href="/sz-docs/assets/js/28.91b5a71e.js"><link rel="prefetch" href="/sz-docs/assets/js/29.745520d1.js"><link rel="prefetch" href="/sz-docs/assets/js/3.79377ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/30.13248181.js"><link rel="prefetch" href="/sz-docs/assets/js/31.faef1119.js"><link rel="prefetch" href="/sz-docs/assets/js/32.35b4c0f9.js"><link rel="prefetch" href="/sz-docs/assets/js/33.549cceab.js"><link rel="prefetch" href="/sz-docs/assets/js/34.8255ba0d.js"><link rel="prefetch" href="/sz-docs/assets/js/35.b405a383.js"><link rel="prefetch" href="/sz-docs/assets/js/36.5a2bf352.js"><link rel="prefetch" href="/sz-docs/assets/js/37.fade1781.js"><link rel="prefetch" href="/sz-docs/assets/js/38.c8d2ce07.js"><link rel="prefetch" href="/sz-docs/assets/js/39.376ae4ae.js"><link rel="prefetch" href="/sz-docs/assets/js/4.da3ef268.js"><link rel="prefetch" href="/sz-docs/assets/js/40.0acd063f.js"><link rel="prefetch" href="/sz-docs/assets/js/41.9f78abdc.js"><link rel="prefetch" href="/sz-docs/assets/js/42.6a89ac09.js"><link rel="prefetch" href="/sz-docs/assets/js/43.bc99f8ea.js"><link rel="prefetch" href="/sz-docs/assets/js/44.69b35b37.js"><link rel="prefetch" href="/sz-docs/assets/js/45.e2b2355f.js"><link rel="prefetch" href="/sz-docs/assets/js/46.effed0fc.js"><link rel="prefetch" href="/sz-docs/assets/js/47.e6a07c4f.js"><link rel="prefetch" href="/sz-docs/assets/js/48.2b8050ee.js"><link rel="prefetch" href="/sz-docs/assets/js/49.56faf412.js"><link rel="prefetch" href="/sz-docs/assets/js/5.dac787d8.js"><link rel="prefetch" href="/sz-docs/assets/js/50.9bf5d2ab.js"><link rel="prefetch" href="/sz-docs/assets/js/51.5dc46630.js"><link rel="prefetch" href="/sz-docs/assets/js/52.a912ec7d.js"><link rel="prefetch" href="/sz-docs/assets/js/53.67bb5c60.js"><link rel="prefetch" href="/sz-docs/assets/js/54.2c797ca7.js"><link rel="prefetch" href="/sz-docs/assets/js/55.3580bd84.js"><link rel="prefetch" href="/sz-docs/assets/js/56.5252541f.js"><link rel="prefetch" href="/sz-docs/assets/js/57.3f36d034.js"><link rel="prefetch" href="/sz-docs/assets/js/58.609e0a8b.js"><link rel="prefetch" href="/sz-docs/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/sz-docs/assets/js/60.d52adccd.js"><link rel="prefetch" href="/sz-docs/assets/js/61.990276f0.js"><link rel="prefetch" href="/sz-docs/assets/js/62.e42f2df7.js"><link rel="prefetch" href="/sz-docs/assets/js/63.34f79dc1.js"><link rel="prefetch" href="/sz-docs/assets/js/7.307492ca.js"><link rel="prefetch" href="/sz-docs/assets/js/8.2b132dc4.js"><link rel="prefetch" href="/sz-docs/assets/js/9.3c5a8fdb.js">
    <link rel="stylesheet" href="/sz-docs/assets/css/0.styles.677476a9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sz-docs/" class="home-link router-link-active"><!----> <span class="site-name">生椰拿铁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  文章
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  文章
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/sz-docs/guide/万字解析 - React Fiber架构.html" class="sidebar-link">第1期：万字解析 - React Fiber架构</a></li><li><a href="/sz-docs/guide/Svelte，未来十年可能取代React和Vue等其他框架的新兴技术.html" class="sidebar-link">第2期：未来之星 - Svelte</a></li><li><a href="/sz-docs/guide/一看就会 - Git篇.html" class="sidebar-link">第3期：一看就会 - Git篇</a></li><li><a href="/sz-docs/guide/意博趣深 - RxJS.html" class="sidebar-link">第4期：意博趣深 - RxJS</a></li><li><a href="/sz-docs/guide/一劳永逸 - CSS布局.html" class="sidebar-link">第5期（上）：一劳永逸 - CSS布局</a></li><li><a href="/sz-docs/guide/CSS前生今世.html" class="sidebar-link">第5期（下）：一劳永逸 - CSS前生今世</a></li><li><a href="/sz-docs/guide/降维打击-Webpack对我们的代码做了什么？.html" class="sidebar-link">第6期：降维打击-Webpack对我们的代码做了什么？</a></li><li><a href="/sz-docs/guide/轮播图篇.html" class="sidebar-link">第7期：相见恨晚 - 轮播图篇</a></li><li><a href="/sz-docs/guide/TypeScript上.html" class="sidebar-link">第8期（上）：通俗易懂 - TypeScript(上)</a></li><li><a href="/sz-docs/guide/TypeScript下.html" class="sidebar-link">第8期（下）：通俗易懂-TypeScript(下)</a></li><li><a href="/sz-docs/guide/从koa到oak.html" class="sidebar-link">第9期：谁主沉浮 - 从koa到oak</a></li><li><a href="/sz-docs/guide/数字空间 - 如何提供稳定可靠服务？.html" class="sidebar-link">第10期：数字空间 - 如何提供稳定可靠服务？</a></li><li><a href="/sz-docs/guide/序列比对-Smith–Waterman算法.html" class="sidebar-link">第11期（上）：序列比对-Smith–Waterman算法</a></li><li><a href="/sz-docs/guide/图布局算法-Sugiyama算法框架.html" class="sidebar-link">第11期（下）：图布局算法-Sugiyama算法框架</a></li><li><a href="/sz-docs/guide/数组进阶 - 数组学到什么样才算精通.html" class="sidebar-link">第12期（上）：数组进阶 - 数组学到什么样才算精通</a></li><li><a href="/sz-docs/guide/复杂度分析 - 这可能是你见过的最好的复杂度分析文章.html" class="sidebar-link">第12期（中）：复杂度分析 - 这可能是你见过的最好的复杂度分析文章</a></li><li><a href="/sz-docs/guide/散列表与二分查找.html" class="sidebar-link">第12期（下）：散列表与二分查找</a></li><li><a href="/sz-docs/guide/Promise漫谈.html" class="sidebar-link">第13期：一诺千金 - Promise漫谈</a></li><li><a href="/sz-docs/guide/编译原理 - 抽象语法树（Abstract Syntax Tree，AST）.html" class="sidebar-link">第14期：编译原理 - 抽象语法树（Abstract Syntax Tree，AST）</a></li><li><a href="/sz-docs/guide/如何写出健壮的CSS.html" class="sidebar-link">第15期（上）：得心应手 - 如何写出健壮的CSS</a></li><li><a href="/sz-docs/guide/CSS3的世界.html" class="sidebar-link">第15期（上）：得心应手 - CSS3的世界</a></li><li><a href="/sz-docs/guide/正则表达式.html" class="sidebar-link">第16期：如鱼得水 - 正则表达式</a></li><li><a href="/sz-docs/guide/由一道面试题想到的.html" class="sidebar-link">第17期：由一道面试题想到的</a></li><li><a href="/sz-docs/guide/浅谈移动端.html" class="sidebar-link">第18期：手机时代 - 浅谈移动端</a></li><li><a href="/sz-docs/guide/js设计模式思想之策略模式思想与发布订阅模式思想.html" class="sidebar-link">第19期： 代码重构 - 浅谈策略模式思想与发布-订阅模式思想</a></li><li><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html" class="sidebar-link">第20期：手写系列 - 简易webpack编译过程</a></li><li><a href="/sz-docs/guide/Vite pourquoi si vite.html" class="sidebar-link">第21期：Vite pourquoi si vite</a></li><li><a href="/sz-docs/guide/WebAssembly.html" class="sidebar-link">第22期：未来已来 - WebAssembly</a></li><li><a href="/sz-docs/guide/浅谈数据压缩.html" class="sidebar-link">第23期：浅谈数据压缩</a></li><li><a href="/sz-docs/guide/第二十四期：Apache POI Excel 和 EasyExcel——读写Excel.html" class="sidebar-link">第24期：Apache POI Excel 和 EasyExcel——读写Excel</a></li><li><a href="/sz-docs/guide/第二十五期：浅谈多线程.html" class="sidebar-link">第25期：浅谈多线程</a></li><li><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html" class="sidebar-link">第26期：霍夫曼编码-Huffman Coding</a></li><li><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html" class="active sidebar-link">第27期：聚类基础-KMean和均值漂移聚类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html#聚类" class="sidebar-link">聚类</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html#k-mean算法" class="sidebar-link">K-Mean算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html#算法过程" class="sidebar-link">算法过程</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html#算法缺陷" class="sidebar-link">算法缺陷</a></li></ul></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html#均值漂移聚类" class="sidebar-link">均值漂移聚类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html#算法过程-2" class="sidebar-link">算法过程</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html#改良" class="sidebar-link">改良</a></li></ul></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html#实际应用" class="sidebar-link">实际应用</a></li></ul></li><li><a href="/sz-docs/guide/web性能优化.html" class="sidebar-link">第28期：web性能优化</a></li><li><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html" class="sidebar-link">第29期：分包吗 - Webpack</a></li><li><a href="/sz-docs/guide/TypeScript类型编程.html" class="sidebar-link">第30期：类型体操 - TypeScript类型编程</a></li><li><a href="/sz-docs/guide/Javasript设计模式之状态模式和代理模式.html" class="sidebar-link">第31期（上）：Javasript设计模式之状态模式和代理模式</a></li><li><a href="/sz-docs/guide/Javasript设计模式之工厂模式和装饰器模式.html" class="sidebar-link">第31期（下）：Javasript设计模式之工厂模式和装饰器模式</a></li><li><a href="/sz-docs/guide/ahooks-一套方便且实用的React Hooks库.html" class="sidebar-link">第32期：ahooks-一套方便且实用的React Hooks库</a></li><li><a href="/sz-docs/guide/Babel-通天塔.html" class="sidebar-link">第33期：Babel-通天塔</a></li><li><a href="/sz-docs/guide/Canvas.html" class="sidebar-link">第34期：Canvas-全集宝典</a></li><li><a href="/sz-docs/guide/WebSocket原理.html" class="sidebar-link">第35期：WebSocket原理</a></li><li><a href="/sz-docs/guide/操作系统——前言.html" class="sidebar-link">第36期：操作系统——前言</a></li><li><a href="/sz-docs/guide/WebSocket数据加密.html" class="sidebar-link"> 第37期：WebSocket数据加密</a></li><li><a href="/sz-docs/guide/Redis五种数据类型实现.html" class="sidebar-link">第38期：Redis五种数据类型实现</a></li><li><a href="/sz-docs/guide/操作系统——启动流程.html" class="sidebar-link">第39期：操作系统——启动流程</a></li><li><a href="/sz-docs/guide/Docker初识.html" class="sidebar-link">第40期：Docker初识</a></li><li><a href="/sz-docs/guide/webpack-runtime.html" class="sidebar-link">第41期：揭开WebpackRuntime的面纱</a></li><li><a href="/sz-docs/guide/grid layout.html" class="sidebar-link">第42期：前端布局大法之grid布局</a></li><li><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html" class="sidebar-link">第43期：Vuejs 3.X源码解析---渲染流程</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="聚类"><a href="#聚类" class="header-anchor">#</a> 聚类</h2> <p><code>聚类</code>是<code>机器学习</code>中一类基础算法。借用百度百科的定义：将物理或抽象<code>对象</code>的<code>集合</code>分成由类似的对象组成的多个<code>类</code>的过程被称为<code>聚类</code>。由聚类所生成的<code>簇</code>是一组数据对象的集合，这些对象与同一个簇中的对象彼此相似，与其他簇中的对象相异。</p> <p>典型问题：把一堆二维点集，按聚集程度区分为若干子集。在下图例子中，这些点被分成了四堆。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/e196d8da9d17c3b91e116df3ef2cd337.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/4b2d6c415b4eb0f48c39dfb17469d24f.jpg" alt=""></p> <h2 id="k-mean算法"><a href="#k-mean算法" class="header-anchor">#</a> K-Mean算法</h2> <p>那么如何设计一个算法让计算机来做到<code>分堆</code>呢？本章介绍最基础、最简单的<code>K-Mean算法</code>。</p> <h3 id="算法过程"><a href="#算法过程" class="header-anchor">#</a> 算法过程</h3> <p>步骤1：假设上图中的点大概可以被分为4堆，那么我们首先确定了类数，在上图中放入4个<code>种子点(seed)</code>，它们的坐标是随机的。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/32bc9e72b28c12ca6cfc0babd812db72.jpg" alt=""></p> <p>步骤2：对于每个<code>样本点</code>来说，计算它到这4个<code>种子点</code>的<code>距离</code>（这里选取<code>欧几里得距离</code>，即根号下(x0-x1)平方+(y0-y1)平方），那么<code>样本点</code>属于离它最近的<code>种子点</code>。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/1d601b0ee6fbbe5e197532929c5e7087.jpg" alt=""></p> <p>步骤3：对于每个<code>种子点</code>来说，移动它到属于它的<code>样本点</code>集合的重心处（样本点x和y的均值）。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/44119ed3c34060ab085219e8fead590e.jpg" alt=""></p> <p>步骤4：重复步骤2和步骤3，直到<code>种子点</code>几乎不再移动（设置一个较小的阈值作为迭代终止条件）。最后各<code>种子点</code>下属的<code>样本点子集</code>，即为区分出的若干类。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/5b103f6deeda4ef45e808f1ca455d979.gif" alt=""></p> <h3 id="算法缺陷"><a href="#算法缺陷" class="header-anchor">#</a> 算法缺陷</h3> <p>从算法过程中，我们能看出使用<code>K-Mean算法</code>需要预先知道总类数，这样才能确定<code>种子点</code>的数量，如果样本数据与预想的总类数之间有出入，会造成“多个子类被聚成一类”或者“本来是一类样本却被分成若干子类”这样的问题。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/6da025478f21a44c97813bf25092913b.gif" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/cee654b5b04f607998a721349366680a.gif" alt=""></p> <h2 id="均值漂移聚类"><a href="#均值漂移聚类" class="header-anchor">#</a> 均值漂移聚类</h2> <p>针对K-Mean算法的缺陷，本章介绍<code>均值漂移聚类算法</code>。该算法不需要预先知道类的数量，会通过样本数据本身的特征计算出类的数量。</p> <h3 id="算法过程-2"><a href="#算法过程-2" class="header-anchor">#</a> 算法过程</h3> <p>步骤1：绘制一定半径的圆作为<code>窗口</code>覆盖若干个<code>样本点</code>，在图上绘制若干个<code>窗口</code>覆盖所有<code>样本点</code>。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/e39423dab228f9162850b9974a73bec4.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/dc7482af942393e3a4cec253c527e36d.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/60b35a790b447f7faa1c990d264e1e5f.jpg" alt=""></p> <p>步骤2：对于每个<code>窗口</code>来说，圆心坐标设置为它覆盖的<code>样本点集</code>的重心，若新覆盖的<code>样本点</code>数量多于上次覆盖数量，重复这个操作，反之停止移动该窗口。直到所有<code>窗口</code>停止移动，结束该步骤。本步骤本质上是让每个<code>窗口</code>朝着覆盖<code>样本点密度</code>高的方向移动。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/60b35a790b447f7faa1c990d264e1e5f.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/f87b4d2c68394e3be74b7e88b3232d12.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/92ed5bb173fdcb7fc95ff3383300f832.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/4c9a8cba8097e64e1ed75b7b1d04fe8b.jpg" alt=""></p> <p>...</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/a04a07037bf20210e637d7b7d3591e9c.jpg" alt=""></p> <p>步骤3：在所有<code>样本点</code>中，找到某个<code>样本点</code>被最多的<code>窗口</code>覆盖。在覆盖该<code>样本点</code>的<code>窗口</code>中，找到某个<code>窗口</code>覆盖的<code>样本点</code>最多，该<code>窗口</code>作为这些<code>窗口</code>的<code>主窗口</code>，同时删除<code>其他窗口</code>。重复该步骤，直到只剩下<code>主窗口</code>。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/1823952d590508b935bc6aa979dde5e8.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/6993b29d3dfc5e27a0d6005b619477a6.jpg" alt=""></p> <p>...</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/f627051856b307b4a3ab52c3c518b474.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/4f9d02e3602a84dc5ff581a9a9bc3677.jpg" alt=""></p> <p>步骤4：以<code>主窗口</code>的圆心作为<code>种子点</code>，使用<code>K-Mean算法</code>，最终对<code>样本点</code>分堆。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/fac5dca92d1a9bd12e2902c249eedc6a.gif" alt=""></p> <h3 id="改良"><a href="#改良" class="header-anchor">#</a> 改良</h3> <p><code>均值漂移聚类算法</code>是在<code>K-Mean算法</code>的基础上，使用<code>窗口漂移</code>的方式来决定<code>种子点</code>的个数和初始位置。这样做到了用样本数据本身的特征来决定类的数量，使聚类效果更佳精准。</p> <h2 id="实际应用"><a href="#实际应用" class="header-anchor">#</a> 实际应用</h2> <p><code>聚类</code>作为机器学习领域中最基本的一类算法，广泛应用于<code>推荐系统</code>（电商的商品推荐、听歌平台的歌曲推荐。。。各种对象的推荐）中。</p> <p>这里举一个<code>CMDB</code>中的真实例子。传统CMDB中的<code>CI（孪生体）</code>往往是靠运维人员手工维护的，它的弊端有更新不及时、维护数据错误等。人们思考是否有不依赖人工的方式来保证CI的准确性，一个简单的逻辑被提出来，线上运行的系统会产生大量日志，这些日志一定反应当前系统或环境的真实情况，所以这些日志一定隐含着当前CI的真实信息，那么是否可以从这些日志中提取隐含的信息来维护CI数据，从而保证CMDB数据的及时性和准确性。</p> <p>下面我们来回答上面的问题。先思考日志是长什么样的，日志一定包含<code>常量</code>部分（如<code>|net_device.dev_name</code>、<code>|net_device.dc_name</code>、<code>|net_device.in_ip</code>等）和<code>变量</code>部分（如<code>XXX-X1X1-YYY2-ZZ01</code>、<code>哈哈区域</code>、<code>11.2.33.4</code>等）。常量一般没什么实际意义，变量往往包含了CI属性的一些信息，那么如何从日志中提取变量信息是一个突破点。</p> <div class="language- extra-class"><pre class="language-text"><code>859		XXX-X1X1-YYY2-ZZ01|net_device.dev_name	哈哈区域|net_device.dc_name	XXX-Y1Y1|net_device.room	99.8.77.6|net_device.in_ip
1718	PPP-Q1Q3-RRR-SS05|net_device.dev_name	PPP-Q1Q|net_device.room
2147	AAA-B1B3-CCC-DD04|net_device.dev_name	AAA-B1B|net_device.room
2577	EEE-F1F2-GGG2-GG02|net_device.dev_name	哈哈区域|net_device.dc_name	EEE-F1F2|net_device.room	11.2.33.4|net_device.in_ip
3006	HHH-I1I2-JJJ2-KK02|net_device.dev_name	哈哈区域|net_device.dc_name	HHH-I1I2|net_device.room	55.6.77.8|net_device.in_ip
3435	LLL-M3-NNN-OO01|net_device.dev_name		嘿嘿区域|net_device.dc_name	LLL-M3|net_device.room	55.44.33.2|net_device.in_ip
...

日志中敏感信息已被涂鸦
</code></pre></div><p>想要取得变量信息，我们需要把同类型的日志放到一起才能找出规律。这一步操作便用到了本文介绍的<code>聚类算法</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>类型1
859		XXX-X1X1-YYY2-ZZ01|net_device.dev_name	哈哈区域|net_device.dc_name	XXX-Y1Y1|net_device.room	99.8.77.6|net_device.in_ip
2577	EEE-F1F2-GGG2-GG02|net_device.dev_name	哈哈区域|net_device.dc_name	EEE-F1F2|net_device.room	11.2.33.4|net_device.in_ip
3006	HHH-I1I2-JJJ2-KK02|net_device.dev_name	哈哈区域|net_device.dc_name	HHH-I1I2|net_device.room	55.6.77.8|net_device.in_ip
3435	LLL-M3-NNN-OO01|net_device.dev_name		嘿嘿区域|net_device.dc_name	LLL-M3|net_device.room	55.44.33.2|net_device.in_ip

类型2
1718	PPP-Q1Q3-RRR-SS05|net_device.dev_name	PPP-Q1Q|net_device.room
2147	AAA-B1B3-CCC-DD04|net_device.dev_name	AAA-B1B|net_device.room

...

类型N
</code></pre></div><p>对于某类日志，我们只需要通过日志数据本身反推出对应的正则表达式。这一步可以使用<a href="https://wiki.uino.com/d/614db4310f0474bf5e735068.html" target="_blank" rel="noopener noreferrer">《序列比对-Smith–Waterman算法》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文章中介绍的算法完成。</p> <p>最后，把各类日志的正则表达式适用到各类日志数据本身，便可以提取出真实有效的CI属性信息了。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html" class="prev">
        第26期：霍夫曼编码-Huffman Coding
      </a></span> <span class="next"><a href="/sz-docs/guide/web性能优化.html">
        第28期：web性能优化
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/sz-docs/assets/js/app.5b32c35c.js" defer></script><script src="/sz-docs/assets/js/2.733019b2.js" defer></script><script src="/sz-docs/assets/js/59.b3529e96.js" defer></script>
  </body>
</html>
