<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据压缩鼻祖 | 生椰拿铁</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="https://static.uino.cn/uino_favicon_32.ico">
    <meta name="description" content="sz docs">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/sz-docs/assets/css/0.styles.677476a9.css" as="style"><link rel="preload" href="/sz-docs/assets/js/app.5b32c35c.js" as="script"><link rel="preload" href="/sz-docs/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/sz-docs/assets/js/62.e42f2df7.js" as="script"><link rel="prefetch" href="/sz-docs/assets/js/10.053ba524.js"><link rel="prefetch" href="/sz-docs/assets/js/11.1159667a.js"><link rel="prefetch" href="/sz-docs/assets/js/12.b7682a80.js"><link rel="prefetch" href="/sz-docs/assets/js/13.b40896ae.js"><link rel="prefetch" href="/sz-docs/assets/js/14.7d6cdd2a.js"><link rel="prefetch" href="/sz-docs/assets/js/15.96809982.js"><link rel="prefetch" href="/sz-docs/assets/js/16.9183fc9e.js"><link rel="prefetch" href="/sz-docs/assets/js/17.ecc2fb02.js"><link rel="prefetch" href="/sz-docs/assets/js/18.cbb699f8.js"><link rel="prefetch" href="/sz-docs/assets/js/19.be221f77.js"><link rel="prefetch" href="/sz-docs/assets/js/20.2607d007.js"><link rel="prefetch" href="/sz-docs/assets/js/21.88cceb8e.js"><link rel="prefetch" href="/sz-docs/assets/js/22.c2db27be.js"><link rel="prefetch" href="/sz-docs/assets/js/23.5ab628b9.js"><link rel="prefetch" href="/sz-docs/assets/js/24.c2cdaaf6.js"><link rel="prefetch" href="/sz-docs/assets/js/25.bb060f6b.js"><link rel="prefetch" href="/sz-docs/assets/js/26.88d6c7f3.js"><link rel="prefetch" href="/sz-docs/assets/js/27.ef250fa3.js"><link rel="prefetch" href="/sz-docs/assets/js/28.91b5a71e.js"><link rel="prefetch" href="/sz-docs/assets/js/29.745520d1.js"><link rel="prefetch" href="/sz-docs/assets/js/3.79377ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/30.13248181.js"><link rel="prefetch" href="/sz-docs/assets/js/31.faef1119.js"><link rel="prefetch" href="/sz-docs/assets/js/32.35b4c0f9.js"><link rel="prefetch" href="/sz-docs/assets/js/33.549cceab.js"><link rel="prefetch" href="/sz-docs/assets/js/34.8255ba0d.js"><link rel="prefetch" href="/sz-docs/assets/js/35.b405a383.js"><link rel="prefetch" href="/sz-docs/assets/js/36.5a2bf352.js"><link rel="prefetch" href="/sz-docs/assets/js/37.fade1781.js"><link rel="prefetch" href="/sz-docs/assets/js/38.c8d2ce07.js"><link rel="prefetch" href="/sz-docs/assets/js/39.376ae4ae.js"><link rel="prefetch" href="/sz-docs/assets/js/4.da3ef268.js"><link rel="prefetch" href="/sz-docs/assets/js/40.0acd063f.js"><link rel="prefetch" href="/sz-docs/assets/js/41.9f78abdc.js"><link rel="prefetch" href="/sz-docs/assets/js/42.6a89ac09.js"><link rel="prefetch" href="/sz-docs/assets/js/43.bc99f8ea.js"><link rel="prefetch" href="/sz-docs/assets/js/44.69b35b37.js"><link rel="prefetch" href="/sz-docs/assets/js/45.e2b2355f.js"><link rel="prefetch" href="/sz-docs/assets/js/46.effed0fc.js"><link rel="prefetch" href="/sz-docs/assets/js/47.e6a07c4f.js"><link rel="prefetch" href="/sz-docs/assets/js/48.2b8050ee.js"><link rel="prefetch" href="/sz-docs/assets/js/49.56faf412.js"><link rel="prefetch" href="/sz-docs/assets/js/5.dac787d8.js"><link rel="prefetch" href="/sz-docs/assets/js/50.9bf5d2ab.js"><link rel="prefetch" href="/sz-docs/assets/js/51.5dc46630.js"><link rel="prefetch" href="/sz-docs/assets/js/52.a912ec7d.js"><link rel="prefetch" href="/sz-docs/assets/js/53.67bb5c60.js"><link rel="prefetch" href="/sz-docs/assets/js/54.2c797ca7.js"><link rel="prefetch" href="/sz-docs/assets/js/55.3580bd84.js"><link rel="prefetch" href="/sz-docs/assets/js/56.5252541f.js"><link rel="prefetch" href="/sz-docs/assets/js/57.3f36d034.js"><link rel="prefetch" href="/sz-docs/assets/js/58.609e0a8b.js"><link rel="prefetch" href="/sz-docs/assets/js/59.b3529e96.js"><link rel="prefetch" href="/sz-docs/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/sz-docs/assets/js/60.d52adccd.js"><link rel="prefetch" href="/sz-docs/assets/js/61.990276f0.js"><link rel="prefetch" href="/sz-docs/assets/js/63.34f79dc1.js"><link rel="prefetch" href="/sz-docs/assets/js/7.307492ca.js"><link rel="prefetch" href="/sz-docs/assets/js/8.2b132dc4.js"><link rel="prefetch" href="/sz-docs/assets/js/9.3c5a8fdb.js">
    <link rel="stylesheet" href="/sz-docs/assets/css/0.styles.677476a9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sz-docs/" class="home-link router-link-active"><!----> <span class="site-name">生椰拿铁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  文章
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  文章
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/sz-docs/guide/万字解析 - React Fiber架构.html" class="sidebar-link">第1期：万字解析 - React Fiber架构</a></li><li><a href="/sz-docs/guide/Svelte，未来十年可能取代React和Vue等其他框架的新兴技术.html" class="sidebar-link">第2期：未来之星 - Svelte</a></li><li><a href="/sz-docs/guide/一看就会 - Git篇.html" class="sidebar-link">第3期：一看就会 - Git篇</a></li><li><a href="/sz-docs/guide/意博趣深 - RxJS.html" class="sidebar-link">第4期：意博趣深 - RxJS</a></li><li><a href="/sz-docs/guide/一劳永逸 - CSS布局.html" class="sidebar-link">第5期（上）：一劳永逸 - CSS布局</a></li><li><a href="/sz-docs/guide/CSS前生今世.html" class="sidebar-link">第5期（下）：一劳永逸 - CSS前生今世</a></li><li><a href="/sz-docs/guide/降维打击-Webpack对我们的代码做了什么？.html" class="sidebar-link">第6期：降维打击-Webpack对我们的代码做了什么？</a></li><li><a href="/sz-docs/guide/轮播图篇.html" class="sidebar-link">第7期：相见恨晚 - 轮播图篇</a></li><li><a href="/sz-docs/guide/TypeScript上.html" class="sidebar-link">第8期（上）：通俗易懂 - TypeScript(上)</a></li><li><a href="/sz-docs/guide/TypeScript下.html" class="sidebar-link">第8期（下）：通俗易懂-TypeScript(下)</a></li><li><a href="/sz-docs/guide/从koa到oak.html" class="sidebar-link">第9期：谁主沉浮 - 从koa到oak</a></li><li><a href="/sz-docs/guide/数字空间 - 如何提供稳定可靠服务？.html" class="sidebar-link">第10期：数字空间 - 如何提供稳定可靠服务？</a></li><li><a href="/sz-docs/guide/序列比对-Smith–Waterman算法.html" class="sidebar-link">第11期（上）：序列比对-Smith–Waterman算法</a></li><li><a href="/sz-docs/guide/图布局算法-Sugiyama算法框架.html" class="sidebar-link">第11期（下）：图布局算法-Sugiyama算法框架</a></li><li><a href="/sz-docs/guide/数组进阶 - 数组学到什么样才算精通.html" class="sidebar-link">第12期（上）：数组进阶 - 数组学到什么样才算精通</a></li><li><a href="/sz-docs/guide/复杂度分析 - 这可能是你见过的最好的复杂度分析文章.html" class="sidebar-link">第12期（中）：复杂度分析 - 这可能是你见过的最好的复杂度分析文章</a></li><li><a href="/sz-docs/guide/散列表与二分查找.html" class="sidebar-link">第12期（下）：散列表与二分查找</a></li><li><a href="/sz-docs/guide/Promise漫谈.html" class="sidebar-link">第13期：一诺千金 - Promise漫谈</a></li><li><a href="/sz-docs/guide/编译原理 - 抽象语法树（Abstract Syntax Tree，AST）.html" class="sidebar-link">第14期：编译原理 - 抽象语法树（Abstract Syntax Tree，AST）</a></li><li><a href="/sz-docs/guide/如何写出健壮的CSS.html" class="sidebar-link">第15期（上）：得心应手 - 如何写出健壮的CSS</a></li><li><a href="/sz-docs/guide/CSS3的世界.html" class="sidebar-link">第15期（上）：得心应手 - CSS3的世界</a></li><li><a href="/sz-docs/guide/正则表达式.html" class="sidebar-link">第16期：如鱼得水 - 正则表达式</a></li><li><a href="/sz-docs/guide/由一道面试题想到的.html" class="sidebar-link">第17期：由一道面试题想到的</a></li><li><a href="/sz-docs/guide/浅谈移动端.html" class="sidebar-link">第18期：手机时代 - 浅谈移动端</a></li><li><a href="/sz-docs/guide/js设计模式思想之策略模式思想与发布订阅模式思想.html" class="sidebar-link">第19期： 代码重构 - 浅谈策略模式思想与发布-订阅模式思想</a></li><li><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html" class="sidebar-link">第20期：手写系列 - 简易webpack编译过程</a></li><li><a href="/sz-docs/guide/Vite pourquoi si vite.html" class="sidebar-link">第21期：Vite pourquoi si vite</a></li><li><a href="/sz-docs/guide/WebAssembly.html" class="sidebar-link">第22期：未来已来 - WebAssembly</a></li><li><a href="/sz-docs/guide/浅谈数据压缩.html" class="sidebar-link">第23期：浅谈数据压缩</a></li><li><a href="/sz-docs/guide/第二十四期：Apache POI Excel 和 EasyExcel——读写Excel.html" class="sidebar-link">第24期：Apache POI Excel 和 EasyExcel——读写Excel</a></li><li><a href="/sz-docs/guide/第二十五期：浅谈多线程.html" class="sidebar-link">第25期：浅谈多线程</a></li><li><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html" class="active sidebar-link">第26期：霍夫曼编码-Huffman Coding</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html#数据压缩鼻祖" class="sidebar-link">数据压缩鼻祖</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html#编码" class="sidebar-link">编码</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html#数据压缩" class="sidebar-link">数据压缩</a></li></ul></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html#霍夫曼编码" class="sidebar-link">霍夫曼编码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html#压缩过程" class="sidebar-link">压缩过程</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html#解压缩过程" class="sidebar-link">解压缩过程</a></li></ul></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html" class="sidebar-link">第27期：聚类基础-KMean和均值漂移聚类</a></li><li><a href="/sz-docs/guide/web性能优化.html" class="sidebar-link">第28期：web性能优化</a></li><li><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html" class="sidebar-link">第29期：分包吗 - Webpack</a></li><li><a href="/sz-docs/guide/TypeScript类型编程.html" class="sidebar-link">第30期：类型体操 - TypeScript类型编程</a></li><li><a href="/sz-docs/guide/Javasript设计模式之状态模式和代理模式.html" class="sidebar-link">第31期（上）：Javasript设计模式之状态模式和代理模式</a></li><li><a href="/sz-docs/guide/Javasript设计模式之工厂模式和装饰器模式.html" class="sidebar-link">第31期（下）：Javasript设计模式之工厂模式和装饰器模式</a></li><li><a href="/sz-docs/guide/ahooks-一套方便且实用的React Hooks库.html" class="sidebar-link">第32期：ahooks-一套方便且实用的React Hooks库</a></li><li><a href="/sz-docs/guide/Babel-通天塔.html" class="sidebar-link">第33期：Babel-通天塔</a></li><li><a href="/sz-docs/guide/Canvas.html" class="sidebar-link">第34期：Canvas-全集宝典</a></li><li><a href="/sz-docs/guide/WebSocket原理.html" class="sidebar-link">第35期：WebSocket原理</a></li><li><a href="/sz-docs/guide/操作系统——前言.html" class="sidebar-link">第36期：操作系统——前言</a></li><li><a href="/sz-docs/guide/WebSocket数据加密.html" class="sidebar-link"> 第37期：WebSocket数据加密</a></li><li><a href="/sz-docs/guide/Redis五种数据类型实现.html" class="sidebar-link">第38期：Redis五种数据类型实现</a></li><li><a href="/sz-docs/guide/操作系统——启动流程.html" class="sidebar-link">第39期：操作系统——启动流程</a></li><li><a href="/sz-docs/guide/Docker初识.html" class="sidebar-link">第40期：Docker初识</a></li><li><a href="/sz-docs/guide/webpack-runtime.html" class="sidebar-link">第41期：揭开WebpackRuntime的面纱</a></li><li><a href="/sz-docs/guide/grid layout.html" class="sidebar-link">第42期：前端布局大法之grid布局</a></li><li><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html" class="sidebar-link">第43期：Vuejs 3.X源码解析---渲染流程</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="数据压缩鼻祖"><a href="#数据压缩鼻祖" class="header-anchor">#</a> 数据压缩鼻祖</h2> <p>近日，看到刘林海同学写的<a href="https://wiki.uino.com/d/61cec49de4e24815550f7fac.html" target="_blank" rel="noopener noreferrer">《浅谈数据压缩》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，很有感触，想起了大学时候写的第一个比较正经的程序<code>霍夫曼编码</code>。记得当年<code>信息论导论</code>课上有一个大作业是实现霍夫曼编码，平常经常逃课打<code>魔兽世界</code>的我瞬间石化了，对着蓝绿底色的<code>Turbo C</code> IDE鼓捣了一个礼拜，总算是交差了。记得当年教科书每章最后都会有一些关于这章内容的轶事，正经知识没学多少，这些小故事倒是看的津津有味。据说70多年前，霍夫曼本人平常也不上课不写作业，后来他的导师怒了说不交作业就不能考试不让毕业。这下霍夫曼急了，只有完成作业才能毕业，于是乎写出了<code>霍夫曼编码</code>，这就是后来<code>数据压缩</code>的基石。真是人比人气死人，同样逃学不写作业，大神就能写出旷世之作。</p> <h3 id="编码"><a href="#编码" class="header-anchor">#</a> 编码</h3> <p>回归正题，在讲<code>数据压缩</code>之前，先介绍下什么是<code>编码</code>。计算机是基于高低电平来运行的，所以要想在计算机内表达一个符号，只能用一串二进制0和1的序列来表示。那么二进制序列和符号之间的一一映射就是<code>编码</code>。<code>编码</code>就像一个密码本，人输入信息进计算机，就会通过这个<code>密码本</code>翻译成计算机能理解的二进制序列。计算机要想把内部的数据输出给人，也要通过这个<code>密码本</code>翻译回人能理解的信息。</p> <p>假如只需要表达英文26个字母，我们可以用下面的方式来编码。</p> <div class="language- extra-class"><pre class="language-text"><code>A -&gt; 0
B -&gt; 1
C -&gt; 10
D -&gt; 11
E -&gt; 100
...
X -&gt; 10111
Y -&gt; 11000
Z -&gt; 11001
</code></pre></div><p>这种<code>编码方式</code>是<code>不定长编码</code>。这种方式会有一个问题，例如二进制<code>10</code>到底表达的是<code>C</code>还是<code>BA</code>呢？所以我们会用<code>定长编码</code>的方式来表达符号，计算机每次会读取相同长度位数的二进制序列出来，和<code>密码本</code>对比后翻译回人能理解的符号。</p> <div class="language- extra-class"><pre class="language-text"><code>A -&gt; 00000
B -&gt; 00001
C -&gt; 00010
D -&gt; 00011
E -&gt; 00100
...
X -&gt; 10111
Y -&gt; 11000
Z -&gt; 11001
</code></pre></div><p>在<code>定长编码</code>体系内，想要表达26个字母，需要5位二进制数（26&lt;32）。常用汉字3000个，那么需要12位二进制数（3000&lt;4098）来表达一个汉字。为了方便使用，IEEE组织会定一些字符集标准来表达世界上几乎所有的符号，比如utf-8、gb2312、iso-8859-1等。计算机会内置这些通用的<code>密码本</code>。其实只要有一套世界通用的<code>密码本</code>就好了，为什么还会有多套呢，这就是大厂间博弈的结果。有人的地方就有江湖，大厂的利益之争无可厚非，只是苦了小白程序员去解<code>乱码BUG</code>，还是<code>希望世界和平</code>。</p> <h3 id="数据压缩"><a href="#数据压缩" class="header-anchor">#</a> 数据压缩</h3> <p>现在考虑一个问题，一篇文章中不可能出现世界上所有的符号，那么对于这篇文章来说，是否不需要用更长的二进制位数来表达一个字符呢？答案是肯定的，但代价是需要一套<code>私有的编码映射</code>。当对数据压缩存储时，需要通过数据本身计算出一套针对这个数据的<code>私有编码映射</code>，再通过它把原数据翻译为<code>压缩数据</code>，最后把<code>私有编码映射</code>和<code>压缩数据</code>同时存储在一起；当对压缩文件解压缩时，会从压缩文件中取出<code>私有编码映射</code>，再通过它把<code>压缩数据</code>翻译回原数据写成文件。在通讯系统中也是一样，发送端会针对报文数据计算出一套<code>私有编码映射</code>，通过它压缩报文后，把<code>私有编码映射</code>和<code>压缩后报文</code>一并发送给接收端；接收端从报文中取出<code>私有编码映射</code>，再通过它把<code>压缩后报文</code>翻译回原文。这就是实现<code>数据压缩</code>的基本思路。</p> <h2 id="霍夫曼编码"><a href="#霍夫曼编码" class="header-anchor">#</a> 霍夫曼编码</h2> <p><code>霍夫曼编码</code>是一种压缩率最高的计算<code>私有编码映射</code>的算法，同时它是一个<code>不定长编码</code>，但它的计算效率并不高。它为什么会是压缩率最高的算法，需要使用<code>信息论</code>的知识进行严格的数学证明，这部分鄙人早已还给了老师，有兴趣的同学可以在评论或新的文章中讨论，到时候也请发给我，学习一下。</p> <p>这里用一个例子介绍算法过程。</p> <div class="language- extra-class"><pre class="language-text"><code>假设标准编码映射如下：
A -&gt; 00000  B -&gt; 00001  C -&gt; 00010  D -&gt; 00011  E -&gt; 00100  F -&gt; 00101
G -&gt; 00110  H -&gt; 00111  I -&gt; 01000  J -&gt; 01001  K -&gt; 01010  L -&gt; 01011
M -&gt; 01100  N -&gt; 01101  O -&gt; 01110  P -&gt; 01111  Q -&gt; 10000  R -&gt; 10001
S -&gt; 10010  T -&gt; 10011  U -&gt; 10100  V -&gt; 10101  W -&gt; 10110  X -&gt; 10111
Y -&gt; 11000  Z -&gt; 11001  空格 -&gt; 11010

符号：        H     E     L     L     O           W     O     R     L     D
对应的二进制：00111 00100 01011 01011 01110 11010 10110 01110 10001 01011 00011
HELLO WORLD的实际存储空间是55个bit位
</code></pre></div><h3 id="压缩过程"><a href="#压缩过程" class="header-anchor">#</a> 压缩过程</h3> <p>步骤1：计算出每个字符出现的概率。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/7189f524ecb8e821e72fe9e06326967b.png" alt=""></p> <p>步骤2：在没有父节点的节点中，找出概率最小和次小的两个节点，建立它们的父节点，父节点的概率值设置为它们的概率和，并设置概率最小的节点的编码值为0，次小为1。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/64740fbe595865fcb37192ec68cbe503.png" alt=""></p> <p>重复步骤2，直到所有节点形成一棵二叉树。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/03caef9aba3de4af44f89af315a7917d.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/1f766f9df22a114a91f38d5c81fa555b.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/4d5d1eadb12173ac04281560c9c98fdd.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/42b134eeab1b80e45567d974a546b968.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/17ab08dac0b4a3e4da7a7deda82859ac.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/98f25f8a054b1a9cfbb89d770627e2e7.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/d585d6c7eab43124e252e175e7fab347.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/478e27f9885491c54810cca756c65457.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/8b23839616a9c97bf1c9c6c4e34225b8.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/60c81df4b32e85759c967c5f4394486e.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/c7fa44d819db308dd6539bde74355ec8.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/fd2d37605db7161f682b6329d6b0cdce.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/8245acb3174e17ce203d619661caef1a.png" alt=""></p> <p>步骤3：在形成的二叉树上，自根部向叶子方向，确定各符号的<code>私有编码映射</code>。以<code>W</code>为例，映射为<code>010</code>。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/574e45e07ad9ef6589e6c6e93b145e94.png" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/e9d1bf4f9a2e0c1ba277e5bf42858b20.png" alt=""></p> <p>步骤4：根据私有编码映射，压缩原符号。</p> <div class="language- extra-class"><pre class="language-text"><code>符号：        H     E     L     L     O           W     O     R     L     D
对应的二进制： 011   001   10    10    110   1110  010   110   1111  10    000
HELLO WORLD的实际存储空间是32个bit位
</code></pre></div><h3 id="解压缩过程"><a href="#解压缩过程" class="header-anchor">#</a> 解压缩过程</h3> <p>对于压缩后二进制序列，根据<code>私有编码映射</code>依次找出<code>以哪个映射开头</code>，来找出对应符号。这里不会出现<code>前文中提到的10到底表达C还是BA的情况</code>，这也是有严格的数学证明的，有兴趣的同学可以在评论或新的文章中来讨论，记得发给我，学习一下。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p><code>霍夫曼编码</code>是一个经典压缩算法。它的核心思想是：利用符号出现的概率不同，让越多出现的符号用越少的<code>编码映射位数</code>来表示。假如在特定数据中，每种符号的出现概率均一样，那么即便压缩后，压缩数据也和原数据的大小一样。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/sz-docs/guide/第二十五期：浅谈多线程.html" class="prev">
        第25期：浅谈多线程
      </a></span> <span class="next"><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html">
        第27期：聚类基础-KMean和均值漂移聚类
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/sz-docs/assets/js/app.5b32c35c.js" defer></script><script src="/sz-docs/assets/js/2.733019b2.js" defer></script><script src="/sz-docs/assets/js/62.e42f2df7.js" defer></script>
  </body>
</html>
