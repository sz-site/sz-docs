<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>生椰拿铁</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="https://static.uino.cn/uino_favicon_32.ico">
    <meta name="description" content="sz docs">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/sz-docs/assets/css/0.styles.677476a9.css" as="style"><link rel="preload" href="/sz-docs/assets/js/app.5b32c35c.js" as="script"><link rel="preload" href="/sz-docs/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/sz-docs/assets/js/54.2c797ca7.js" as="script"><link rel="prefetch" href="/sz-docs/assets/js/10.053ba524.js"><link rel="prefetch" href="/sz-docs/assets/js/11.1159667a.js"><link rel="prefetch" href="/sz-docs/assets/js/12.b7682a80.js"><link rel="prefetch" href="/sz-docs/assets/js/13.b40896ae.js"><link rel="prefetch" href="/sz-docs/assets/js/14.7d6cdd2a.js"><link rel="prefetch" href="/sz-docs/assets/js/15.96809982.js"><link rel="prefetch" href="/sz-docs/assets/js/16.9183fc9e.js"><link rel="prefetch" href="/sz-docs/assets/js/17.ecc2fb02.js"><link rel="prefetch" href="/sz-docs/assets/js/18.cbb699f8.js"><link rel="prefetch" href="/sz-docs/assets/js/19.be221f77.js"><link rel="prefetch" href="/sz-docs/assets/js/20.2607d007.js"><link rel="prefetch" href="/sz-docs/assets/js/21.88cceb8e.js"><link rel="prefetch" href="/sz-docs/assets/js/22.c2db27be.js"><link rel="prefetch" href="/sz-docs/assets/js/23.5ab628b9.js"><link rel="prefetch" href="/sz-docs/assets/js/24.c2cdaaf6.js"><link rel="prefetch" href="/sz-docs/assets/js/25.bb060f6b.js"><link rel="prefetch" href="/sz-docs/assets/js/26.88d6c7f3.js"><link rel="prefetch" href="/sz-docs/assets/js/27.ef250fa3.js"><link rel="prefetch" href="/sz-docs/assets/js/28.91b5a71e.js"><link rel="prefetch" href="/sz-docs/assets/js/29.745520d1.js"><link rel="prefetch" href="/sz-docs/assets/js/3.79377ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/30.13248181.js"><link rel="prefetch" href="/sz-docs/assets/js/31.faef1119.js"><link rel="prefetch" href="/sz-docs/assets/js/32.35b4c0f9.js"><link rel="prefetch" href="/sz-docs/assets/js/33.549cceab.js"><link rel="prefetch" href="/sz-docs/assets/js/34.8255ba0d.js"><link rel="prefetch" href="/sz-docs/assets/js/35.b405a383.js"><link rel="prefetch" href="/sz-docs/assets/js/36.5a2bf352.js"><link rel="prefetch" href="/sz-docs/assets/js/37.fade1781.js"><link rel="prefetch" href="/sz-docs/assets/js/38.c8d2ce07.js"><link rel="prefetch" href="/sz-docs/assets/js/39.376ae4ae.js"><link rel="prefetch" href="/sz-docs/assets/js/4.da3ef268.js"><link rel="prefetch" href="/sz-docs/assets/js/40.0acd063f.js"><link rel="prefetch" href="/sz-docs/assets/js/41.9f78abdc.js"><link rel="prefetch" href="/sz-docs/assets/js/42.6a89ac09.js"><link rel="prefetch" href="/sz-docs/assets/js/43.bc99f8ea.js"><link rel="prefetch" href="/sz-docs/assets/js/44.69b35b37.js"><link rel="prefetch" href="/sz-docs/assets/js/45.e2b2355f.js"><link rel="prefetch" href="/sz-docs/assets/js/46.effed0fc.js"><link rel="prefetch" href="/sz-docs/assets/js/47.e6a07c4f.js"><link rel="prefetch" href="/sz-docs/assets/js/48.2b8050ee.js"><link rel="prefetch" href="/sz-docs/assets/js/49.56faf412.js"><link rel="prefetch" href="/sz-docs/assets/js/5.dac787d8.js"><link rel="prefetch" href="/sz-docs/assets/js/50.9bf5d2ab.js"><link rel="prefetch" href="/sz-docs/assets/js/51.5dc46630.js"><link rel="prefetch" href="/sz-docs/assets/js/52.a912ec7d.js"><link rel="prefetch" href="/sz-docs/assets/js/53.67bb5c60.js"><link rel="prefetch" href="/sz-docs/assets/js/55.3580bd84.js"><link rel="prefetch" href="/sz-docs/assets/js/56.5252541f.js"><link rel="prefetch" href="/sz-docs/assets/js/57.3f36d034.js"><link rel="prefetch" href="/sz-docs/assets/js/58.609e0a8b.js"><link rel="prefetch" href="/sz-docs/assets/js/59.b3529e96.js"><link rel="prefetch" href="/sz-docs/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/sz-docs/assets/js/60.d52adccd.js"><link rel="prefetch" href="/sz-docs/assets/js/61.990276f0.js"><link rel="prefetch" href="/sz-docs/assets/js/62.e42f2df7.js"><link rel="prefetch" href="/sz-docs/assets/js/63.34f79dc1.js"><link rel="prefetch" href="/sz-docs/assets/js/7.307492ca.js"><link rel="prefetch" href="/sz-docs/assets/js/8.2b132dc4.js"><link rel="prefetch" href="/sz-docs/assets/js/9.3c5a8fdb.js">
    <link rel="stylesheet" href="/sz-docs/assets/css/0.styles.677476a9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sz-docs/" class="home-link router-link-active"><!----> <span class="site-name">生椰拿铁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  文章
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  文章
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/sz-docs/guide/万字解析 - React Fiber架构.html" class="sidebar-link">第1期：万字解析 - React Fiber架构</a></li><li><a href="/sz-docs/guide/Svelte，未来十年可能取代React和Vue等其他框架的新兴技术.html" class="sidebar-link">第2期：未来之星 - Svelte</a></li><li><a href="/sz-docs/guide/一看就会 - Git篇.html" class="sidebar-link">第3期：一看就会 - Git篇</a></li><li><a href="/sz-docs/guide/意博趣深 - RxJS.html" class="sidebar-link">第4期：意博趣深 - RxJS</a></li><li><a href="/sz-docs/guide/一劳永逸 - CSS布局.html" class="sidebar-link">第5期（上）：一劳永逸 - CSS布局</a></li><li><a href="/sz-docs/guide/CSS前生今世.html" class="sidebar-link">第5期（下）：一劳永逸 - CSS前生今世</a></li><li><a href="/sz-docs/guide/降维打击-Webpack对我们的代码做了什么？.html" class="sidebar-link">第6期：降维打击-Webpack对我们的代码做了什么？</a></li><li><a href="/sz-docs/guide/轮播图篇.html" class="sidebar-link">第7期：相见恨晚 - 轮播图篇</a></li><li><a href="/sz-docs/guide/TypeScript上.html" class="sidebar-link">第8期（上）：通俗易懂 - TypeScript(上)</a></li><li><a href="/sz-docs/guide/TypeScript下.html" class="sidebar-link">第8期（下）：通俗易懂-TypeScript(下)</a></li><li><a href="/sz-docs/guide/从koa到oak.html" class="sidebar-link">第9期：谁主沉浮 - 从koa到oak</a></li><li><a href="/sz-docs/guide/数字空间 - 如何提供稳定可靠服务？.html" class="sidebar-link">第10期：数字空间 - 如何提供稳定可靠服务？</a></li><li><a href="/sz-docs/guide/序列比对-Smith–Waterman算法.html" class="sidebar-link">第11期（上）：序列比对-Smith–Waterman算法</a></li><li><a href="/sz-docs/guide/图布局算法-Sugiyama算法框架.html" class="sidebar-link">第11期（下）：图布局算法-Sugiyama算法框架</a></li><li><a href="/sz-docs/guide/数组进阶 - 数组学到什么样才算精通.html" class="sidebar-link">第12期（上）：数组进阶 - 数组学到什么样才算精通</a></li><li><a href="/sz-docs/guide/复杂度分析 - 这可能是你见过的最好的复杂度分析文章.html" class="sidebar-link">第12期（中）：复杂度分析 - 这可能是你见过的最好的复杂度分析文章</a></li><li><a href="/sz-docs/guide/散列表与二分查找.html" class="sidebar-link">第12期（下）：散列表与二分查找</a></li><li><a href="/sz-docs/guide/Promise漫谈.html" class="sidebar-link">第13期：一诺千金 - Promise漫谈</a></li><li><a href="/sz-docs/guide/编译原理 - 抽象语法树（Abstract Syntax Tree，AST）.html" class="sidebar-link">第14期：编译原理 - 抽象语法树（Abstract Syntax Tree，AST）</a></li><li><a href="/sz-docs/guide/如何写出健壮的CSS.html" class="sidebar-link">第15期（上）：得心应手 - 如何写出健壮的CSS</a></li><li><a href="/sz-docs/guide/CSS3的世界.html" class="sidebar-link">第15期（上）：得心应手 - CSS3的世界</a></li><li><a href="/sz-docs/guide/正则表达式.html" class="sidebar-link">第16期：如鱼得水 - 正则表达式</a></li><li><a href="/sz-docs/guide/由一道面试题想到的.html" class="sidebar-link">第17期：由一道面试题想到的</a></li><li><a href="/sz-docs/guide/浅谈移动端.html" class="sidebar-link">第18期：手机时代 - 浅谈移动端</a></li><li><a href="/sz-docs/guide/js设计模式思想之策略模式思想与发布订阅模式思想.html" class="sidebar-link">第19期： 代码重构 - 浅谈策略模式思想与发布-订阅模式思想</a></li><li><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html" class="sidebar-link">第20期：手写系列 - 简易webpack编译过程</a></li><li><a href="/sz-docs/guide/Vite pourquoi si vite.html" class="sidebar-link">第21期：Vite pourquoi si vite</a></li><li><a href="/sz-docs/guide/WebAssembly.html" class="sidebar-link">第22期：未来已来 - WebAssembly</a></li><li><a href="/sz-docs/guide/浅谈数据压缩.html" class="sidebar-link">第23期：浅谈数据压缩</a></li><li><a href="/sz-docs/guide/第二十四期：Apache POI Excel 和 EasyExcel——读写Excel.html" class="sidebar-link">第24期：Apache POI Excel 和 EasyExcel——读写Excel</a></li><li><a href="/sz-docs/guide/第二十五期：浅谈多线程.html" class="sidebar-link">第25期：浅谈多线程</a></li><li><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html" class="sidebar-link">第26期：霍夫曼编码-Huffman Coding</a></li><li><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html" class="sidebar-link">第27期：聚类基础-KMean和均值漂移聚类</a></li><li><a href="/sz-docs/guide/web性能优化.html" class="sidebar-link">第28期：web性能优化</a></li><li><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html" class="active sidebar-link">第29期：分包吗 - Webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html#entry-分包处理" class="sidebar-link">Entry 分包处理</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html#异步模块分包处理" class="sidebar-link">异步模块分包处理</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html#runtime-分包" class="sidebar-link">Runtime 分包</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html#根据-module-使用频率分包" class="sidebar-link">根据 Module 使用频率分包</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html#限制分包数量" class="sidebar-link">限制分包数量</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html#限制分包体积数" class="sidebar-link">限制分包体积数</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html#缓存组" class="sidebar-link">缓存组</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html#默认分组" class="sidebar-link">默认分组</a></li></ul></li><li><a href="/sz-docs/guide/TypeScript类型编程.html" class="sidebar-link">第30期：类型体操 - TypeScript类型编程</a></li><li><a href="/sz-docs/guide/Javasript设计模式之状态模式和代理模式.html" class="sidebar-link">第31期（上）：Javasript设计模式之状态模式和代理模式</a></li><li><a href="/sz-docs/guide/Javasript设计模式之工厂模式和装饰器模式.html" class="sidebar-link">第31期（下）：Javasript设计模式之工厂模式和装饰器模式</a></li><li><a href="/sz-docs/guide/ahooks-一套方便且实用的React Hooks库.html" class="sidebar-link">第32期：ahooks-一套方便且实用的React Hooks库</a></li><li><a href="/sz-docs/guide/Babel-通天塔.html" class="sidebar-link">第33期：Babel-通天塔</a></li><li><a href="/sz-docs/guide/Canvas.html" class="sidebar-link">第34期：Canvas-全集宝典</a></li><li><a href="/sz-docs/guide/WebSocket原理.html" class="sidebar-link">第35期：WebSocket原理</a></li><li><a href="/sz-docs/guide/操作系统——前言.html" class="sidebar-link">第36期：操作系统——前言</a></li><li><a href="/sz-docs/guide/WebSocket数据加密.html" class="sidebar-link"> 第37期：WebSocket数据加密</a></li><li><a href="/sz-docs/guide/Redis五种数据类型实现.html" class="sidebar-link">第38期：Redis五种数据类型实现</a></li><li><a href="/sz-docs/guide/操作系统——启动流程.html" class="sidebar-link">第39期：操作系统——启动流程</a></li><li><a href="/sz-docs/guide/Docker初识.html" class="sidebar-link">第40期：Docker初识</a></li><li><a href="/sz-docs/guide/webpack-runtime.html" class="sidebar-link">第41期：揭开WebpackRuntime的面纱</a></li><li><a href="/sz-docs/guide/grid layout.html" class="sidebar-link">第42期：前端布局大法之grid布局</a></li><li><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html" class="sidebar-link">第43期：Vuejs 3.X源码解析---渲染流程</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>chunk是输出产物的基本组织单位，在生成阶段 webpack 按规则将 entry 及其它 module 插入 chunk 中，之后再由 SplitChunksPlugin 插件根据优化规则与 ChunkGraph 对 chunk 做一系列的变化、拆解、合并操作，重新组织成一批性能(可能)更高的 chunks 。运行完毕之后 webpack 继续将 chunk 一一写入物理文件中，完成编译工作。</p> <p>本文将会介绍webpack 基本的分包规则，以及如何通过配置SplitChunksPlugin、ChunkGraph优化分包</p> <h1 id="默认分包规则"><a href="#默认分包规则" class="header-anchor">#</a> 默认分包规则</h1> <p>默认有以下规则：(默认规则集中在compilation.seal 函数实现)</p> <ul><li>同一个entry下触达到的模块组织成一个 chunk</li> <li>异步模块单独组织为一个 chunk</li> <li>entry.runtime单独组织成一个 chunk</li></ul> <h2 id="entry-分包处理"><a href="#entry-分包处理" class="header-anchor">#</a> Entry 分包处理</h2> <blockquote><p>seal 阶段遍历 entry 对象，为每一个 entry 单独生成 chunk，之后再根据模块依赖图将 entry 触达到的所有模块打包进 chunk 中。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// 比如对于如下配置：
module.exports = {
  entry: {
   entry1: &quot;./src/entry1&quot;,
   entry2: &quot;./src/entry2&quot;,
  }
};
</code></pre></div><p>遍历 entry 对象属性并创建出 chunk[entry1] 、chunk[entry2] 两个对象，最后形成如下两个chunk：<br> <img src="https://pan.udolphin.com/files/image/2022/3/e7b5c2afa326bf9b4c44e87edc87f91d.png" alt=""></p> <p>生成的dist目录如下：(<em>基于 entry 生成的 chunk 通常称之为「Initial chunk」</em>)</p> <p><img src="https://pan.udolphin.com/files/image/2022/3/992a6f08c5df0b9c7c81f2bbe672bfbb.png" alt=""></p> <h2 id="异步模块分包处理"><a href="#异步模块分包处理" class="header-anchor">#</a> 异步模块分包处理</h2> <blockquote><p>遇到异步模块则创建单独的 Chunk 对象，单独打包异步模块，其子模块也都加入这个 chunk 中。</p></blockquote> <p>Webpack 4 之后，只需要用异步语句 require.ensure('./a.js') 或 import('./a.js') 方式引入模块，就可以实现模块的动态加载。</p> <div class="language- extra-class"><pre class="language-text"><code>// entry1.js
require('a.js')
require('b.js')
​
// entry2.js
require('c.js')
require.ensure([], function(require){
  require('./async-d.js');
});

// async-d.js
require('e.js')
</code></pre></div><p>在 entry1 中，以同步方式引入 a.js、b.js；entry2以异步方式引入 async-d.js 模块；在async-d.js 中以同步方式引入 e.js 模块。对应的模块依赖如：</p> <p><img src="https://pan.udolphin.com/files/image/2022/3/e3d6df65f873eb6fd821b82d89065480.png" alt=""></p> <p>生成的dist目录如下：(<em>基于异步模块的 chunk 通常称之为「Async chunk」</em>)</p> <p><img src="https://pan.udolphin.com/files/image/2022/3/17f0259df62dd4c206d95f6eb07e91f1.png" alt=""></p> <p>异步生成的chunk ，chunk间会形成父子关系。引用者(上例 entry-2)需要在特定场景下使用被引用者(上例 async-d)，两者间存在单向依赖关系，在 webpack 中称引用者为 parent、被引用者为 child。</p> <p>运行时，webpack 在 entry2 中使用 promise 及 __webpack_require__.e 方法异步载入并运行文件 async-d-chunk.js ，从而实现动态加载。</p> <h2 id="runtime-分包"><a href="#runtime-分包" class="header-anchor">#</a> Runtime 分包</h2> <blockquote><p>Webpack 5 之后支持根据 entry.runtime 配置单独打包运行时代码。</p></blockquote> <p>除业务代码外，Webpack 编译产物中还需要包含一些用于支持 webpack 模块化、异步加载等特性的支撑性代码，这类代码在 webpack 中被统称为 runtime。举个例子，产物中通常会包含如下代码：</p> <div class="language- extra-class"><pre class="language-text"><code>/******/ (() =&gt; { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ &quot;./src/entry1.js&quot;:
/*!***********************!*\
  !*** ./src/entry1.js ***!
  \***********************/
/***/ (() =&gt; {

eval(&quot;\n\n//# sourceURL=webpack://webpack-make/./src/entry1.js?&quot;);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__[&quot;./src/entry1.js&quot;]();
/******/ 	
/******/ })()
;
</code></pre></div><p>编译时，Webpack 会根据业务代码决定输出那些支撑特性的运行时代码，例如：</p> <p>需要 __webpack_require__.f 、__webpack_require__.r 等功能实现最起码的模块化支持</p> <p>如果用到动态加载特性，则需要写入__webpack_require__.e函数</p> <p>如果用到 Module Federation 特性，则需要写入__webpack_require__.o函数等等</p> <p>虽然每段运行时代码可能都很小，但随着特性的增加，最终结果会越来越大，特别对于多 entry 应用，在每个入口都重复打包一份相似的运行时代码显得有点浪费，为此 webpack 5 专门提供了 entry.runtime 配置项用于声明如何打包运行时代码。用法上只需在 entry 项中增加字符串形式的 runtime 值，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  entry: {
   entry1: { import: &quot;./src/entry1&quot;, runtime: &quot;solid-runtime&quot; },
  }
};
</code></pre></div><p>Webpack 执行完 entry、异步模块分包后，开始遍历 entry 配置判断是否带有runtime属性，如果有则创建以runtime值为名的 chunk，生成的dist目录如下：</p> <p><img src="https://pan.udolphin.com/files/image/2022/3/61ee4b86cb22fdab72c4764be69fd04f.png" alt=""></p> <p>在多 entry 场景中，只要为每个 entry 都设定相同的 runtime 值，webpack 运行时代码最终就会集中写入到同一个 chunk，例如对于如下配置：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  entry: {
    entry1: { import: './src/entry1', runtime: 'solid-runtime' },
    entry2: { import: './src/entry2', runtime: 'solid-runtime' }
  }
};
</code></pre></div><p>生成的dist目录如下：<br> <img src="https://pan.udolphin.com/files/image/2022/3/58d3bc80d7b39b69f55d05a50a86c6c7.png" alt=""></p> <h1 id="默认分包规则的问题"><a href="#默认分包规则的问题" class="header-anchor">#</a> 默认分包规则的问题</h1> <p>默认分包规则最大的问题是无法解决模块重复，如果多个 chunk 同时包含同一个 module，那么这个 module 会被不受限制地重复打包进这些 chunk。对最终产物可能造成不必要的性能损耗。</p> <p>Webpack 会将所有代码构建成一个单独的包，这在小型项目通常不会有明显的性能问题，但伴随着项目的推进，包体积逐步增长可能会导致应用的响应耗时越来越长。归根结底这种将所有资源打包成一个文件的方式存在两个弊端：</p> <p>「资源冗余」：客户端必须等待整个应用的代码包都加载完毕才能启动运行，但可能用户当下访问的内容只需要使用其中一部分代码</p> <p>「缓存失效」：将所有资源达成一个包后，所有改动 —— 即使只是修改了一个字符，客户端都需要重新下载整个代码包，缓存命中率极低</p> <p>这些问题都可以通过对产物做适当的分解拆包解决，例如 node_mopdules 中的资源通常变动较少，可以抽成一个独立的包，那么业务代码的频繁变动不会导致这部分第三方库资源被无意义地重复加载。为此，Webpack 专门提供了 SplitChunkslugin 插件，用于实现产物分包。</p> <h1 id="splitchunksplugin"><a href="#splitchunksplugin" class="header-anchor">#</a> SplitChunksPlugin</h1> <p>SplitChunksPlugin 默认只对 Async Chunk 生效，开发者也可以通过 webpack.config.js 调整作用范围，该配置项支持如下值：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: 'all',
    },
  },
}
</code></pre></div><ul><li>'all'：对 Initial Chunk 与 Async Chunk 都生效，建议优先使用该值</li> <li>'initial'：只对 Initial Chunk 生效</li> <li>'async' ：只对 Async Chunk 生效</li> <li>(chunk) =&gt; boolean：该函数返回 true 时生效</li></ul> <h2 id="根据-module-使用频率分包"><a href="#根据-module-使用频率分包" class="header-anchor">#</a> 根据 Module 使用频率分包</h2> <p>按 Module 被 Chunk 引用的次数决定是否进行分包，可通过以下方式设定最小引用次数，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
 //...
 optimization: {
  splitChunks: {
    chunks： 'all',
   minChunks: 2, // 引用次数&lt;=2的模块不进行分包
   },
  },
}
</code></pre></div><p><img src="https://pan.udolphin.com/files/image/2022/3/eb076814c57b4486ee6d9a9186efa9aa.png" alt=""></p> <p>生成的dist目录如下：</p> <p><img src="https://pan.udolphin.com/files/image/2022/3/1a6bbc0cf451cc2ed92b370a124ad3ad.png" alt=""></p> <h2 id="限制分包数量"><a href="#限制分包数量" class="header-anchor">#</a> 限制分包数量</h2> <p>在满足 minChunks 基础上，还可以通过 maxInitialRequests / maxAsyncRequests 配置项限定分包数量，配置项语义：</p> <p>maxInitialRequests：用于设置 Initial Chunk 最大并行请求数</p> <p>maxAsyncRequests：用于设置 Async Chunk 最大并行请求数</p> <p>这里所说的“请求数”，是指加载一个 Chunk 时所需同步加载的分包数。例如对于一个 Chunk A，如果根据分包规则(如模块引用次数、第三方包)分离出了若干子 Chunk A¡，那么请求 A 时，浏览器需要同时请求所有的 A¡，此时并行请求数等于 ¡ 个分包加 A 主包，即 ¡+1。</p> <p>而对于下述模块关系：</p> <p><img src="https://pan.udolphin.com/files/image/2022/3/4bfd335173a724c2f7b40ad388f47208.png" alt=""></p> <p>若 minChunks = 2，则 common-1、common-2 同时命中 minChunks 规则被分别打包，浏览器请求 entry-b 时需要同时请求 comon-1、common-2 两个分包，并行数为 2 + 1 = 3，此时若 maxInitialRequests = 2 ，则分包数超过阈值，SplitChunksPlugin 会放弃 comon-1、common-2 中体积较小的分包。maxAsyncRequests 逻辑与此类似，不在赘述。</p> <p>并行请求数关键逻辑总结如下：</p> <p>Initial Chunk 本身算一个请求</p> <p>Async Chunk 不算并行请求</p> <p>通过 runtimeChunk 拆分出的 runtime 不算并行请求</p> <p>如果同时有两个 Chunk 满足拆分规则，但是 maxInitialRequests（或maxAsyncRequestss）的值只能允许再拆分一个模块，那么体积更大的模块会被优先拆解</p> <h2 id="限制分包体积数"><a href="#限制分包体积数" class="header-anchor">#</a> 限制分包体积数</h2> <p>在满足 minChunks 与 maxAsyncRequests 的基础上，SplitChunksPlugin 还会进一步判断 Chunk 包大小决定是否分包，这一规则相关的配置项非常多：</p> <ul><li>minSize：超过这个尺寸的 Chunk 才会正式被分包</li> <li>maxSize：超过这个尺寸的 Chunk 会尝试继续做分包</li> <li>maxAsyncSize：与maxSize 功能类似，但只对异步引入的模块生效</li> <li>maxInitialSize：与maxSize 类似，但只对entry 配置的入口模块生效</li> <li>enforceSizeThreshold：超过这个尺寸的 Chunk 会被强制分包，忽略上述其它 size 限制</li></ul> <p>结合前面介绍的两种规则，SplitChunksPlugin 的主体流程如下：</p> <ol><li>SplitChunksPlugin 尝试将命中 minChunks 规则的 Module 统一抽到一个额外的 Chunk 对象；</li> <li>判断该 Chunk 是否满足 maxInitialRequests 阈值，若满足则进行下一步</li> <li>判断该 Chunk 资源的体积是否大于上述配置项 minSize 声明的下限阈值；</li> <li>如果体积「小于」 minSize 则取消这次分包，对应的 Module 依然会被合并入原来的 Chunk</li> <li>如果 Chunk 体积「大于」minSize 则判断是否超过 maxSize、maxAsyncSize、maxInitialSize 声明的上限阈值，如果超过则尝试将该 Chunk 继续分割成更小的部分</li></ol> <blockquote><p>虽然 maxSize 等上限阈值逻辑会产生更多的包体，但缓存粒度会更小，命中率相对也会更高，配合持久缓存与 HTTP 2 的多路复用能力，网络性能反而会有正向收益。</p></blockquote> <p>以上述模块为例</p> <p><img src="https://pan.udolphin.com/files/image/2022/3/eb076814c57b4486ee6d9a9186efa9aa.png" alt=""></p> <p>若此时 minChunks 大于 2，且 maxInitialRequests 也大于 2，如果 common 模块的体积大于上述说明的 minSize 配置项则分包成功，common 会被分离为单独的 Chunk，否则会被合并入原来的 3 个 Chunk。</p> <blockquote><p>优先级顺序：maxInitialRequests/maxAsyncSize &lt; maxSize &lt; minSize ，命中 enforceSizeThreshold 阈值的 Chunk 会直接跳过这些属性判断，强制进行分包。</p></blockquote> <h1 id="cachegroups"><a href="#cachegroups" class="header-anchor">#</a> CacheGroups</h1> <h2 id="缓存组"><a href="#缓存组" class="header-anchor">#</a> 缓存组</h2> <p>除上述规则外，SplitChunksPlugin 还提供了 cacheGroups 配置项用于为不同文件组设置不同的规则，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
 //...
 optimization: {
  splitChunks: {
   cacheGroups: {
    vendors: {
      test: /[\\/]node_modules[\\/]/,
      minChunks: 1,
      minSize: 0
     }
    },
   },
  },
};
</code></pre></div><p>示例通过 cacheGroups 属性设置 vendors 缓存组，所有命中 vendors.test 规则的模块都会被视作 vendors 分组，优先应用该组下的 minChunks、minSize 等分包配置。</p> <p>除了 minChunks 等分包基础配置项之外，cacheGroups 还支持一些与分组逻辑强相关的属性，包括：</p> <ul><li>test：接受正则表达式、函数及字符串，所有符合 test 判断的 Module 或 Chunk 都会被分到该组</li> <li>type：接受正则表达式、函数及字符串，与 test 类似均用于筛选分组命中的模块，区别是它判断的依据是文件类型而不是文件名，例如 type='json' 会命中所有 JSON 文件</li> <li>idHint：字符串型，用于设置 Chunk ID，它还会被追加到最终产物文件名中，例如 idHint = 'vendors' 时，输出产物文件名形如 vendors-xxx-xxx.js</li> <li>priority：数字型，用于设置该分组的优先级，若模块命中多个缓存组，则优先被分到 priority 更大的组</li></ul> <p>缓存组的作用在于能为不同类型的资源设置更具适用性的分包规则，一个典型场景是将所有 node_modules 下的模块统一打包到 vendors 产物，从而实现第三方库与业务代码的分离。</p> <h2 id="默认分组"><a href="#默认分组" class="header-anchor">#</a> 默认分组</h2> <p>Webpack 提供了两个开箱即用的 cacheGroups ，分别命名为 default 与 defaultVendors ，默认配置：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
 //...
 optimization: {
  splitChunks: {
   cacheGroups: {
    default: {
     idHint: &quot;&quot;,
     reuseExistingChunk: true,
     minChunks: 2,
     priority: -20
     },
    defaultVendors: {
     idHint: &quot;vendors&quot;,
     reuseExistingChunk: true,
     test: /[\\/]node_modules[\\/]/i,
     priority: -10
     }
    },
   },
  },
};
</code></pre></div><p>这两个配置组能帮助我们：</p> <ul><li>将所有 node_modules 中的资源单独打包到 vendors-xxx-xxx.js 命名的产物</li> <li>对引用次数大于等于 2 的模块，也就是被多个 Chunk 引用的模块，单独打包</li></ul> <p>开发者也可以将默认分组设置为 false，关闭分组配置，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
 //...
 optimization: {
  splitChunks: {
   cacheGroups: {
    default: false
    },
   },
  },
};
</code></pre></div><h1 id="拆分运行时包"><a href="#拆分运行时包" class="header-anchor">#</a> 拆分运行时包</h1> <p>运行时代码的内容由业务代码所使用到的特性决定，例如当 Webpack 检测到业务代码中使用了异步加载能力，就会将异步加载相关的运行时注入到产物中，因此业务代码用到的特性越多，运行时就会越大，有时甚至可以超过 1M 之多。此时，可以将运行时代码拆分到一个独立的 Chunk，实现分包。配置如下：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  //...
  optimization: {
	runtimeChunk: true,
  }
}
</code></pre></div><p>默认值为false，即每个条目块嵌入运行时。</p> <p>这一配置用于优化持久化缓存, runtime 指的是 webpack 的运行环境(具体作用就是模块解析, 加载) 和 模块信息清单, 模块信息清单在每次有模块变更(hash 变更)时都会变更, 所以我们想把这部分代码单独打包出来, 配合后端缓存策略, 这样就不会因为某个模块的变更导致包含模块信息的模块(通常会被包含在最后一个 bundle 中)缓存失效. optimization.runtimeChunk 就是告诉 webpack 是否要把这部分单独打包出来.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/sz-docs/guide/web性能优化.html" class="prev">
        第28期：web性能优化
      </a></span> <span class="next"><a href="/sz-docs/guide/TypeScript类型编程.html">
        第30期：类型体操 - TypeScript类型编程
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/sz-docs/assets/js/app.5b32c35c.js" defer></script><script src="/sz-docs/assets/js/2.733019b2.js" defer></script><script src="/sz-docs/assets/js/54.2c797ca7.js" defer></script>
  </body>
</html>
