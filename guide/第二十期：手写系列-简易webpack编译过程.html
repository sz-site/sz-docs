<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前言 | 生椰拿铁</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="https://static.uino.cn/uino_favicon_32.ico">
    <meta name="description" content="sz docs">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/sz-docs/assets/css/0.styles.677476a9.css" as="style"><link rel="preload" href="/sz-docs/assets/js/app.5b32c35c.js" as="script"><link rel="preload" href="/sz-docs/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/sz-docs/assets/js/57.3f36d034.js" as="script"><link rel="prefetch" href="/sz-docs/assets/js/10.053ba524.js"><link rel="prefetch" href="/sz-docs/assets/js/11.1159667a.js"><link rel="prefetch" href="/sz-docs/assets/js/12.b7682a80.js"><link rel="prefetch" href="/sz-docs/assets/js/13.b40896ae.js"><link rel="prefetch" href="/sz-docs/assets/js/14.7d6cdd2a.js"><link rel="prefetch" href="/sz-docs/assets/js/15.96809982.js"><link rel="prefetch" href="/sz-docs/assets/js/16.9183fc9e.js"><link rel="prefetch" href="/sz-docs/assets/js/17.ecc2fb02.js"><link rel="prefetch" href="/sz-docs/assets/js/18.cbb699f8.js"><link rel="prefetch" href="/sz-docs/assets/js/19.be221f77.js"><link rel="prefetch" href="/sz-docs/assets/js/20.2607d007.js"><link rel="prefetch" href="/sz-docs/assets/js/21.88cceb8e.js"><link rel="prefetch" href="/sz-docs/assets/js/22.c2db27be.js"><link rel="prefetch" href="/sz-docs/assets/js/23.5ab628b9.js"><link rel="prefetch" href="/sz-docs/assets/js/24.c2cdaaf6.js"><link rel="prefetch" href="/sz-docs/assets/js/25.bb060f6b.js"><link rel="prefetch" href="/sz-docs/assets/js/26.88d6c7f3.js"><link rel="prefetch" href="/sz-docs/assets/js/27.ef250fa3.js"><link rel="prefetch" href="/sz-docs/assets/js/28.91b5a71e.js"><link rel="prefetch" href="/sz-docs/assets/js/29.745520d1.js"><link rel="prefetch" href="/sz-docs/assets/js/3.79377ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/30.13248181.js"><link rel="prefetch" href="/sz-docs/assets/js/31.faef1119.js"><link rel="prefetch" href="/sz-docs/assets/js/32.35b4c0f9.js"><link rel="prefetch" href="/sz-docs/assets/js/33.549cceab.js"><link rel="prefetch" href="/sz-docs/assets/js/34.8255ba0d.js"><link rel="prefetch" href="/sz-docs/assets/js/35.b405a383.js"><link rel="prefetch" href="/sz-docs/assets/js/36.5a2bf352.js"><link rel="prefetch" href="/sz-docs/assets/js/37.fade1781.js"><link rel="prefetch" href="/sz-docs/assets/js/38.c8d2ce07.js"><link rel="prefetch" href="/sz-docs/assets/js/39.376ae4ae.js"><link rel="prefetch" href="/sz-docs/assets/js/4.da3ef268.js"><link rel="prefetch" href="/sz-docs/assets/js/40.0acd063f.js"><link rel="prefetch" href="/sz-docs/assets/js/41.9f78abdc.js"><link rel="prefetch" href="/sz-docs/assets/js/42.6a89ac09.js"><link rel="prefetch" href="/sz-docs/assets/js/43.bc99f8ea.js"><link rel="prefetch" href="/sz-docs/assets/js/44.69b35b37.js"><link rel="prefetch" href="/sz-docs/assets/js/45.e2b2355f.js"><link rel="prefetch" href="/sz-docs/assets/js/46.effed0fc.js"><link rel="prefetch" href="/sz-docs/assets/js/47.e6a07c4f.js"><link rel="prefetch" href="/sz-docs/assets/js/48.2b8050ee.js"><link rel="prefetch" href="/sz-docs/assets/js/49.56faf412.js"><link rel="prefetch" href="/sz-docs/assets/js/5.dac787d8.js"><link rel="prefetch" href="/sz-docs/assets/js/50.9bf5d2ab.js"><link rel="prefetch" href="/sz-docs/assets/js/51.5dc46630.js"><link rel="prefetch" href="/sz-docs/assets/js/52.a912ec7d.js"><link rel="prefetch" href="/sz-docs/assets/js/53.67bb5c60.js"><link rel="prefetch" href="/sz-docs/assets/js/54.2c797ca7.js"><link rel="prefetch" href="/sz-docs/assets/js/55.3580bd84.js"><link rel="prefetch" href="/sz-docs/assets/js/56.5252541f.js"><link rel="prefetch" href="/sz-docs/assets/js/58.609e0a8b.js"><link rel="prefetch" href="/sz-docs/assets/js/59.b3529e96.js"><link rel="prefetch" href="/sz-docs/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/sz-docs/assets/js/60.d52adccd.js"><link rel="prefetch" href="/sz-docs/assets/js/61.990276f0.js"><link rel="prefetch" href="/sz-docs/assets/js/62.e42f2df7.js"><link rel="prefetch" href="/sz-docs/assets/js/63.34f79dc1.js"><link rel="prefetch" href="/sz-docs/assets/js/7.307492ca.js"><link rel="prefetch" href="/sz-docs/assets/js/8.2b132dc4.js"><link rel="prefetch" href="/sz-docs/assets/js/9.3c5a8fdb.js">
    <link rel="stylesheet" href="/sz-docs/assets/css/0.styles.677476a9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sz-docs/" class="home-link router-link-active"><!----> <span class="site-name">生椰拿铁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  文章
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  文章
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/sz-docs/guide/万字解析 - React Fiber架构.html" class="sidebar-link">第1期：万字解析 - React Fiber架构</a></li><li><a href="/sz-docs/guide/Svelte，未来十年可能取代React和Vue等其他框架的新兴技术.html" class="sidebar-link">第2期：未来之星 - Svelte</a></li><li><a href="/sz-docs/guide/一看就会 - Git篇.html" class="sidebar-link">第3期：一看就会 - Git篇</a></li><li><a href="/sz-docs/guide/意博趣深 - RxJS.html" class="sidebar-link">第4期：意博趣深 - RxJS</a></li><li><a href="/sz-docs/guide/一劳永逸 - CSS布局.html" class="sidebar-link">第5期（上）：一劳永逸 - CSS布局</a></li><li><a href="/sz-docs/guide/CSS前生今世.html" class="sidebar-link">第5期（下）：一劳永逸 - CSS前生今世</a></li><li><a href="/sz-docs/guide/降维打击-Webpack对我们的代码做了什么？.html" class="sidebar-link">第6期：降维打击-Webpack对我们的代码做了什么？</a></li><li><a href="/sz-docs/guide/轮播图篇.html" class="sidebar-link">第7期：相见恨晚 - 轮播图篇</a></li><li><a href="/sz-docs/guide/TypeScript上.html" class="sidebar-link">第8期（上）：通俗易懂 - TypeScript(上)</a></li><li><a href="/sz-docs/guide/TypeScript下.html" class="sidebar-link">第8期（下）：通俗易懂-TypeScript(下)</a></li><li><a href="/sz-docs/guide/从koa到oak.html" class="sidebar-link">第9期：谁主沉浮 - 从koa到oak</a></li><li><a href="/sz-docs/guide/数字空间 - 如何提供稳定可靠服务？.html" class="sidebar-link">第10期：数字空间 - 如何提供稳定可靠服务？</a></li><li><a href="/sz-docs/guide/序列比对-Smith–Waterman算法.html" class="sidebar-link">第11期（上）：序列比对-Smith–Waterman算法</a></li><li><a href="/sz-docs/guide/图布局算法-Sugiyama算法框架.html" class="sidebar-link">第11期（下）：图布局算法-Sugiyama算法框架</a></li><li><a href="/sz-docs/guide/数组进阶 - 数组学到什么样才算精通.html" class="sidebar-link">第12期（上）：数组进阶 - 数组学到什么样才算精通</a></li><li><a href="/sz-docs/guide/复杂度分析 - 这可能是你见过的最好的复杂度分析文章.html" class="sidebar-link">第12期（中）：复杂度分析 - 这可能是你见过的最好的复杂度分析文章</a></li><li><a href="/sz-docs/guide/散列表与二分查找.html" class="sidebar-link">第12期（下）：散列表与二分查找</a></li><li><a href="/sz-docs/guide/Promise漫谈.html" class="sidebar-link">第13期：一诺千金 - Promise漫谈</a></li><li><a href="/sz-docs/guide/编译原理 - 抽象语法树（Abstract Syntax Tree，AST）.html" class="sidebar-link">第14期：编译原理 - 抽象语法树（Abstract Syntax Tree，AST）</a></li><li><a href="/sz-docs/guide/如何写出健壮的CSS.html" class="sidebar-link">第15期（上）：得心应手 - 如何写出健壮的CSS</a></li><li><a href="/sz-docs/guide/CSS3的世界.html" class="sidebar-link">第15期（上）：得心应手 - CSS3的世界</a></li><li><a href="/sz-docs/guide/正则表达式.html" class="sidebar-link">第16期：如鱼得水 - 正则表达式</a></li><li><a href="/sz-docs/guide/由一道面试题想到的.html" class="sidebar-link">第17期：由一道面试题想到的</a></li><li><a href="/sz-docs/guide/浅谈移动端.html" class="sidebar-link">第18期：手机时代 - 浅谈移动端</a></li><li><a href="/sz-docs/guide/js设计模式思想之策略模式思想与发布订阅模式思想.html" class="sidebar-link">第19期： 代码重构 - 浅谈策略模式思想与发布-订阅模式思想</a></li><li><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html" class="active sidebar-link">第20期：手写系列 - 简易webpack编译过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#why-webpack" class="sidebar-link">Why Webpack ?</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#概念" class="sidebar-link">概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#entry" class="sidebar-link">entry</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#chunk" class="sidebar-link">chunk</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#bundle" class="sidebar-link">bundle</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#output" class="sidebar-link">Output</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#loader" class="sidebar-link">Loader</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#plugin" class="sidebar-link">Plugin</a></li></ul></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#编译过程" class="sidebar-link">编译过程</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#path" class="sidebar-link">path</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#path-join" class="sidebar-link">- path.join</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#path-resolve" class="sidebar-link">- path.resolve</a></li></ul></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#fs" class="sidebar-link">fs</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#fs-readfilesync" class="sidebar-link">- fs.readFileSync</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#fs-writefilesync" class="sidebar-link">- fs.writeFileSync</a></li></ul></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#babel" class="sidebar-link">babel</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#babel-parser" class="sidebar-link">@babel/parser</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#babel-traverse" class="sidebar-link">@babel/traverse</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#babel-core" class="sidebar-link">@babel/core</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html#babel-preset-env" class="sidebar-link">@babel/preset-env</a></li></ul></li></ul></li><li><a href="/sz-docs/guide/Vite pourquoi si vite.html" class="sidebar-link">第21期：Vite pourquoi si vite</a></li><li><a href="/sz-docs/guide/WebAssembly.html" class="sidebar-link">第22期：未来已来 - WebAssembly</a></li><li><a href="/sz-docs/guide/浅谈数据压缩.html" class="sidebar-link">第23期：浅谈数据压缩</a></li><li><a href="/sz-docs/guide/第二十四期：Apache POI Excel 和 EasyExcel——读写Excel.html" class="sidebar-link">第24期：Apache POI Excel 和 EasyExcel——读写Excel</a></li><li><a href="/sz-docs/guide/第二十五期：浅谈多线程.html" class="sidebar-link">第25期：浅谈多线程</a></li><li><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html" class="sidebar-link">第26期：霍夫曼编码-Huffman Coding</a></li><li><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html" class="sidebar-link">第27期：聚类基础-KMean和均值漂移聚类</a></li><li><a href="/sz-docs/guide/web性能优化.html" class="sidebar-link">第28期：web性能优化</a></li><li><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html" class="sidebar-link">第29期：分包吗 - Webpack</a></li><li><a href="/sz-docs/guide/TypeScript类型编程.html" class="sidebar-link">第30期：类型体操 - TypeScript类型编程</a></li><li><a href="/sz-docs/guide/Javasript设计模式之状态模式和代理模式.html" class="sidebar-link">第31期（上）：Javasript设计模式之状态模式和代理模式</a></li><li><a href="/sz-docs/guide/Javasript设计模式之工厂模式和装饰器模式.html" class="sidebar-link">第31期（下）：Javasript设计模式之工厂模式和装饰器模式</a></li><li><a href="/sz-docs/guide/ahooks-一套方便且实用的React Hooks库.html" class="sidebar-link">第32期：ahooks-一套方便且实用的React Hooks库</a></li><li><a href="/sz-docs/guide/Babel-通天塔.html" class="sidebar-link">第33期：Babel-通天塔</a></li><li><a href="/sz-docs/guide/Canvas.html" class="sidebar-link">第34期：Canvas-全集宝典</a></li><li><a href="/sz-docs/guide/WebSocket原理.html" class="sidebar-link">第35期：WebSocket原理</a></li><li><a href="/sz-docs/guide/操作系统——前言.html" class="sidebar-link">第36期：操作系统——前言</a></li><li><a href="/sz-docs/guide/WebSocket数据加密.html" class="sidebar-link"> 第37期：WebSocket数据加密</a></li><li><a href="/sz-docs/guide/Redis五种数据类型实现.html" class="sidebar-link">第38期：Redis五种数据类型实现</a></li><li><a href="/sz-docs/guide/操作系统——启动流程.html" class="sidebar-link">第39期：操作系统——启动流程</a></li><li><a href="/sz-docs/guide/Docker初识.html" class="sidebar-link">第40期：Docker初识</a></li><li><a href="/sz-docs/guide/webpack-runtime.html" class="sidebar-link">第41期：揭开WebpackRuntime的面纱</a></li><li><a href="/sz-docs/guide/grid layout.html" class="sidebar-link">第42期：前端布局大法之grid布局</a></li><li><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html" class="sidebar-link">第43期：Vuejs 3.X源码解析---渲染流程</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>webpack 5.0 版本之后，Webpack 功能集变得非常庞大，仅注释就有10000+行，70000+行代码。</p> <h2 id="why-webpack"><a href="#why-webpack" class="header-anchor">#</a> Why Webpack ?</h2> <ul><li>因为我们需要从某个地方导入一些文件，我们可以使用webpack来解释这些语句。</li> <li>因为我们知道我们需要连接和压缩JavaScript，并且管理加载顺序。</li> <li>因为npm。强大的功能是一个yarn 或npm i，因此我们的项目被加载伴随着导入的填充。</li> <li>因为在这个行业中有一个蜂群思维，它导致我们和大多数人一起跳上一列火车，而人们在webpack火车的窗户外等待。</li></ul> <h2 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h2> <h3 id="entry"><a href="#entry" class="header-anchor">#</a> entry</h3> <ul><li>入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。</li> <li>进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的</li> <li>每个依赖项随即被处理,最后输出到称之为 bundles 的文件中</li></ul> <p>支持三种形式：字符串、数组、对象</p> <p>数组：webpack会⾃动⽣成另外⼀个⼊⼝模块，并将数组中的每个指定的模块加载进来，并将最后⼀个模块的module.exports作为⼊⼝模块的module.exports导出。</p> <h3 id="chunk"><a href="#chunk" class="header-anchor">#</a> chunk</h3> <p>代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</p> <p>1 chunk = 1bundle</p> <p>chunk是代码块，bundle是资源⽂件</p> <p>什么是模块？nodeJS⾥ 万物皆模块，即文件</p> <h3 id="bundle"><a href="#bundle" class="header-anchor">#</a> bundle</h3> <p>资源文件</p> <h3 id="output"><a href="#output" class="header-anchor">#</a> Output</h3> <p>output 属性告诉 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。</p> <p>基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。</p> <h3 id="loader"><a href="#loader" class="header-anchor">#</a> Loader</h3> <ul><li>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。</li> <li>loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力，对它们进行处理。</li> <li>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</li></ul> <h3 id="plugin"><a href="#plugin" class="header-anchor">#</a> Plugin</h3> <p>loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。</p> <p>插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。</p> <blockquote><p>当我们会用一样东西的时候，就要适当地去了解一下这个东西是怎么运转的。</p></blockquote> <h2 id="编译过程"><a href="#编译过程" class="header-anchor">#</a> 编译过程</h2> <p>Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 :</p> <ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。</li> <li>开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。</li> <li>确定入口：根据配置中的 entry 找出所有的入口文件。</li> <li>编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</li> <li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li> <li>输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。</li> <li>输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。</li></ol> <p>在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p> <blockquote></blockquote> <p>创建一个bundle.js文件</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// bundle.js</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./lib/webpack.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack.config.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">webpack</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>执行命令</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>node bundle<span class="token punctuation">.</span>js
</code></pre></div><p>首先 ，定义一个 webpack类</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">webpack</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> entry<span class="token punctuation">,</span> output <span class="token punctuation">}</span> <span class="token operator">=</span> options<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>entry <span class="token operator">=</span> entry<span class="token punctuation">;</span>    <span class="token comment">// 入口文件</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>output <span class="token operator">=</span> output<span class="token punctuation">;</span>  <span class="token comment">// 输出文件</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>modules <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 存储各文件信息</span>
  <span class="token punctuation">}</span>
  
  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>     <span class="token comment">// 执行编译</span>
  
  <span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 编译</span>
  
  <span class="token function">file</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment">// 输出文件</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接下来编译模块</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">parse</span><span class="token punctuation">(</span><span class="token parameter">entryFile</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 获取模块内容</span>
  <span class="token keyword">const</span> content <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>entryFile<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 分析模块，收集依赖 其实就是将用import语句引入的文件路径收集起来</span>
  <span class="token comment">// - 将内容转化为 ast 语法树</span>
  <span class="token keyword">const</span> ast <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">sourceType</span><span class="token operator">:</span> <span class="token string">'module'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// - 定义一个依赖对象，将收集起来的路径放到dependency里</span>
  <span class="token keyword">const</span> dependency <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token comment">// - 找出 ast 语法树中 导入的文件，并将其相对路径和绝对路径存入依赖中</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">ImportDeclaration</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> node <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> newPathName <span class="token operator">=</span>
            <span class="token string">'./'</span> <span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>entryFile<span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>source<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      dependency<span class="token punctuation">[</span>node<span class="token punctuation">.</span>source<span class="token punctuation">.</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> newPathName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 内容处理 将 ast语法树 转换成浏览器认识的代码</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> code <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">transformFromAst</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">presets</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'@babel/preset-env'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 将编译处理过的信息返回</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    entryFile<span class="token punctuation">,</span>
    dependency<span class="token punctuation">,</span>
    code
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上一步已经找出了从入口文件开始的一系列依赖文件，转换过的代码</p> <p>接下来，试着去执行编译</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 得到编译后的信息</span>
  <span class="token keyword">const</span> info <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 把信息放入 modules 数组里</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>modules<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 循环数组，根据依赖关系遍历并存入 modules</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>modules<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> item <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>modules<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> yilai <span class="token punctuation">}</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dependency<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> j <span class="token keyword">in</span> dependency<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>modules<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>dependency<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 初始化依赖图对象</span>
  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 将上面得到的依赖信息放入依赖图中</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>modules<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">[</span>item<span class="token punctuation">.</span>entryFile<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">dependency</span><span class="token operator">:</span> item<span class="token punctuation">.</span>dependency<span class="token punctuation">,</span>
      <span class="token literal-property property">code</span><span class="token operator">:</span> item<span class="token punctuation">.</span>code
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此，已经得到了一个依赖图。</p> <p>接下来，需要找到输出路径并且输出到相应文件中</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">file</span><span class="token punctuation">(</span><span class="token parameter">code</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 拼接输出文件路径</span>
  <span class="token keyword">const</span> filePath <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>output<span class="token punctuation">.</span>path<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>output<span class="token punctuation">.</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">let</span> template <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./template.js'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>
  template <span class="token operator">=</span> template<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'__entry__'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>entry<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'__modules_content__'</span><span class="token punctuation">,</span> newCode<span class="token punctuation">)</span>
  
  <span class="token comment">// 写入文件</span>
  fs<span class="token punctuation">.</span><span class="token function">writeFileSync</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> template<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// template.js</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">modules</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// modules就是一个数组，元素就是一个个函数体，就是我们声明的模块</span>

  <span class="token keyword">function</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">pathRequire</span><span class="token punctuation">(</span><span class="token parameter">relativePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// relativePath: ./a.js -&gt; ./src/a.js</span>
      <span class="token keyword">return</span> <span class="token function">require</span><span class="token punctuation">(</span>modules<span class="token punctuation">[</span>module<span class="token punctuation">]</span><span class="token punctuation">.</span>yilai<span class="token punctuation">[</span>relativePath<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> code</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">eval</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>pathRequire<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> modules<span class="token punctuation">[</span>module<span class="token punctuation">]</span><span class="token punctuation">.</span>code<span class="token punctuation">)</span>

    <span class="token keyword">return</span> exports<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'__entry__'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">(</span>__modules_content__<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>生成bundle文件实质上是拼接出一个bundle.js文件内容的字符串，然后通过<code>fs.writeFileSync</code>写入到bundle.js文件。我们就仿照实际webpack的打包文件（webpack输出文件分析）来拼接字符串。整个输出文件是一个自执行函数。</p> <ol><li>把保存下来的depsGraph，传入一个立即执行函数。</li> <li>将主模块路径传入require函数执行</li> <li>执行reuire函数的时候，又立即执行一个立即执行函数，这里是把code的值传进去了</li> <li>执行eval（code）。也就是执行主模块的code这段代码</li></ol> <p><code>webpack</code>打包编译的时候，会统一替换成自己的<code>require</code>来实现模块的引入和导出，从而实现模块缓存机制，以及抹平不同模块规范之间的一些差异性。</p> <p>最后</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  <span class="token operator">...</span>
  
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">file</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="path"><a href="#path" class="header-anchor">#</a> path</h2> <h3 id="path-join"><a href="#path-join" class="header-anchor">#</a> - path.join</h3> <p>( [...paths] )</p> <blockquote><ul><li><code>...paths</code> string 路径片段的序列</li> <li>返回: string</li></ul></blockquote> <p><code>path.join()</code> 方法使用特定于平台的分隔符作为定界符将所有给定的 <code>path</code> 片段连接在一起，然后规范化生成的路径。</p> <p>零长度的 <code>path</code> 片段被忽略。 如果连接的路径字符串是零长度字符串，则将返回 <code>'.'</code>，表示当前工作目录。</p> <h3 id="path-resolve"><a href="#path-resolve" class="header-anchor">#</a> - path.resolve</h3> <p>( [...paths] )</p> <blockquote><ul><li><code>...paths</code> string 路径或路径片段的序列</li> <li>返回: string</li></ul></blockquote> <p><code>path.resolve()</code> 方法将路径或路径片段的序列解析为绝对路径。</p> <p>给定的路径序列从右到左处理，每个后续的 <code>path</code> 会被追加到前面，直到构建绝对路径。 例如，给定路径片段的序列：<code>/foo</code>、<code>/bar</code>、<code>baz</code>，调用 <code>path.resolve('/foo', '/bar', 'baz')</code> 将返回 <code>/bar/baz</code>，因为 <code>'baz'</code> 不是绝对路径，而 <code>'/bar' + '/' + 'baz'</code> 是。</p> <p>如果在处理完所有给定的 <code>path</code> 片段之后，还没有生成绝对路径，则使用当前工作目录。</p> <p>生成的路径被规范化，并删除尾部斜杠（除非路径解析为根目录）。</p> <p>零长度的 <code>path</code> 片段被忽略。</p> <p>如果没有传入 <code>path</code> 片段，则 <code>path.resolve()</code> 将返回当前工作目录的绝对路径。</p> <h2 id="fs"><a href="#fs" class="header-anchor">#</a> fs</h2> <h3 id="fs-readfilesync"><a href="#fs-readfilesync" class="header-anchor">#</a> - fs.readFileSync</h3> <p>(path[,options])</p> <blockquote><ul><li><code>path</code> string | Buffer | integer文件名或文件描述符</li> <li>options  Object | string
<ul><li><code>encoding</code> string | null <strong>默认值:</strong> <code>null</code></li> <li><code>flag</code> string。</li></ul></li> <li>return string | Buffer</li></ul></blockquote> <p>返回 <code>path</code> 的内容。如果指定了 <code>encoding</code> 选项，则此函数返回字符串。 否则它返回Buffer</p> <blockquote><p>UTF-8 (UCS Transformation Format 8)是万维网上最常用的字符编码</p> <p>字符编码：</p> <p>一套编码系统定义字节与文本间的映射。一连串字节文本能让不同文本解释得以进行。我们指明一套特定编码系统时（如 UTF-8），也就指明了字节得以解释的方式。</p> <p>例如，我们通常在 HTML 里声明 UTF-8 字符编码，使用如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;meta charset=&quot;utf-8&quot;&gt;
</code></pre></div><p>这就确保你在 HTML 文档中可以使用几乎任何一种人类语言中的字符，并且会稳定显示。</p></blockquote> <h3 id="fs-writefilesync"><a href="#fs-writefilesync" class="header-anchor">#</a> - fs.writeFileSync</h3> <p>（file, data[,options]）</p> <blockquote><ul><li><code>file</code>  string | Buffer | URL |  integer 文件名或文件描述符</li> <li><code>data</code>  string | Buffer | TypeArray | DataView | Object</li> <li><code>options</code>  Object |  string
<ul><li><code>encoding</code>   string | null 默认值: <code>'utf8'</code></li> <li><code>mode</code> integer 默认值: <code>0o666</code></li> <li><code>flag</code> integer 默认值: <code>'w'</code>。</li></ul></li> <li>return undefined</li></ul></blockquote> <p>当 <code>file</code> 是文件名时，将数据同步地写入文件，如果文件已存在则替换该文件。 <code>data</code> 可以是字符串或缓冲区。</p> <p>当 <code>file</code> 是文件描述符时，其行为类似于直接调用 <code>fs.write()</code>。</p> <p>如果 <code>data</code> 是缓冲区，则忽略 <code>encoding</code> 选项。</p> <p><code>mode</code> 选项仅影响新创建的文件。 有关详细信息，请参阅 <code>fs.open()</code>。</p> <p>如果 <code>data</code> 是普通的对象，则它必须具有自有的（不是继承的）<code>toString</code> 函数属性。</p> <h2 id="babel"><a href="#babel" class="header-anchor">#</a> babel</h2> <h3 id="babel-parser"><a href="#babel-parser" class="header-anchor">#</a> @babel/parser</h3> <p>(code, [options])</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> i @babel/parser <span class="token parameter variable">-D</span>
</code></pre></div><p>Babel 使用的 JavaScript 解析器，将代码转换成 AST 树</p> <p>此处 options 配置为</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">sourceType</span><span class="token operator">:</span> <span class="token string">'module'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>指明模式的代码应解析。三种模式：<code>script</code>，<code>module</code>或<code>unambiguous</code>。默认为 <code>script</code>。 <code>unambiguous</code>将使 @babel/parser 尝试根据 ES6或语句的存在来<em>猜测</em>。带有 ES6  imports 和 exports 的文件被看作 <code>module</code> ，否则看作 <code>script</code>。</p> <h3 id="babel-traverse"><a href="#babel-traverse" class="header-anchor">#</a> @babel/traverse</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> i @babel/traverse <span class="token parameter variable">-D</span>
</code></pre></div><p>可以用它来查找 AST 语法树中特定的节点类型</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> traverse <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@babel/traverse'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>default<span class="token punctuation">;</span>

<span class="token function">traverse</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">ImportDeclaration</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> node <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> newPathName <span class="token operator">=</span> <span class="token string">'./'</span> <span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>entryFile<span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>source<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    yilai<span class="token punctuation">[</span>node<span class="token punctuation">.</span>source<span class="token punctuation">.</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> newPathName<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="babel-core"><a href="#babel-core" class="header-anchor">#</a> @babel/core</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> i @babel/core <span class="token parameter variable">-D</span>
</code></pre></div><p>babel 核心</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> transformFromAst <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@babel/core'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 内容处理</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> code <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">transformFromAst</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">presets</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'@babel/preset-env'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这一步可以将 AST语法树 转换成ES5</p> <p>处理此文件时要激活的一组预设。有关单个条目如何交互的更多信息，尤其是在跨多个嵌套<a href="https://babel.docschina.org/docs/en/options/#env" target="_blank" rel="noopener noreferrer"><code>&quot;env&quot;</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和 <a href="https://babel.docschina.org/docs/en/options/#overrides" target="_blank" rel="noopener noreferrer"><code>&quot;overrides&quot;</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>配置使用时，请参阅<a href="https://babel.docschina.org/docs/en/options/#merging" target="_blank" rel="noopener noreferrer">合并<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>注意：预设的格式与插件相同，除了名称规范化需要“预设-”而不是“插件-”，并且预设不能是<code>Plugin</code>.</p> <h3 id="babel-preset-env"><a href="#babel-preset-env" class="header-anchor">#</a> @babel/preset-env</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> i @babel/core <span class="token parameter variable">-D</span>
</code></pre></div><p>是一个智能预设，允许您使用最新的 JavaScript，而无需对目标环境需要哪些语法转换（以及可选的浏览器 polyfill）进行微观管理。这会让  JavaScript 包更小。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/sz-docs/guide/js设计模式思想之策略模式思想与发布订阅模式思想.html" class="prev">
        第19期： 代码重构 - 浅谈策略模式思想与发布-订阅模式思想
      </a></span> <span class="next"><a href="/sz-docs/guide/Vite pourquoi si vite.html">
        第21期：Vite pourquoi si vite
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/sz-docs/assets/js/app.5b32c35c.js" defer></script><script src="/sz-docs/assets/js/2.733019b2.js" defer></script><script src="/sz-docs/assets/js/57.3f36d034.js" defer></script>
  </body>
</html>
