<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>回顾 | 生椰拿铁</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="https://static.uino.cn/uino_favicon_32.ico">
    <meta name="description" content="sz docs">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/sz-docs/assets/css/0.styles.677476a9.css" as="style"><link rel="preload" href="/sz-docs/assets/js/app.5b32c35c.js" as="script"><link rel="preload" href="/sz-docs/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/sz-docs/assets/js/29.745520d1.js" as="script"><link rel="prefetch" href="/sz-docs/assets/js/10.053ba524.js"><link rel="prefetch" href="/sz-docs/assets/js/11.1159667a.js"><link rel="prefetch" href="/sz-docs/assets/js/12.b7682a80.js"><link rel="prefetch" href="/sz-docs/assets/js/13.b40896ae.js"><link rel="prefetch" href="/sz-docs/assets/js/14.7d6cdd2a.js"><link rel="prefetch" href="/sz-docs/assets/js/15.96809982.js"><link rel="prefetch" href="/sz-docs/assets/js/16.9183fc9e.js"><link rel="prefetch" href="/sz-docs/assets/js/17.ecc2fb02.js"><link rel="prefetch" href="/sz-docs/assets/js/18.cbb699f8.js"><link rel="prefetch" href="/sz-docs/assets/js/19.be221f77.js"><link rel="prefetch" href="/sz-docs/assets/js/20.2607d007.js"><link rel="prefetch" href="/sz-docs/assets/js/21.88cceb8e.js"><link rel="prefetch" href="/sz-docs/assets/js/22.c2db27be.js"><link rel="prefetch" href="/sz-docs/assets/js/23.5ab628b9.js"><link rel="prefetch" href="/sz-docs/assets/js/24.c2cdaaf6.js"><link rel="prefetch" href="/sz-docs/assets/js/25.bb060f6b.js"><link rel="prefetch" href="/sz-docs/assets/js/26.88d6c7f3.js"><link rel="prefetch" href="/sz-docs/assets/js/27.ef250fa3.js"><link rel="prefetch" href="/sz-docs/assets/js/28.91b5a71e.js"><link rel="prefetch" href="/sz-docs/assets/js/3.79377ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/30.13248181.js"><link rel="prefetch" href="/sz-docs/assets/js/31.faef1119.js"><link rel="prefetch" href="/sz-docs/assets/js/32.35b4c0f9.js"><link rel="prefetch" href="/sz-docs/assets/js/33.549cceab.js"><link rel="prefetch" href="/sz-docs/assets/js/34.8255ba0d.js"><link rel="prefetch" href="/sz-docs/assets/js/35.b405a383.js"><link rel="prefetch" href="/sz-docs/assets/js/36.5a2bf352.js"><link rel="prefetch" href="/sz-docs/assets/js/37.fade1781.js"><link rel="prefetch" href="/sz-docs/assets/js/38.c8d2ce07.js"><link rel="prefetch" href="/sz-docs/assets/js/39.376ae4ae.js"><link rel="prefetch" href="/sz-docs/assets/js/4.da3ef268.js"><link rel="prefetch" href="/sz-docs/assets/js/40.0acd063f.js"><link rel="prefetch" href="/sz-docs/assets/js/41.9f78abdc.js"><link rel="prefetch" href="/sz-docs/assets/js/42.6a89ac09.js"><link rel="prefetch" href="/sz-docs/assets/js/43.bc99f8ea.js"><link rel="prefetch" href="/sz-docs/assets/js/44.69b35b37.js"><link rel="prefetch" href="/sz-docs/assets/js/45.e2b2355f.js"><link rel="prefetch" href="/sz-docs/assets/js/46.effed0fc.js"><link rel="prefetch" href="/sz-docs/assets/js/47.e6a07c4f.js"><link rel="prefetch" href="/sz-docs/assets/js/48.2b8050ee.js"><link rel="prefetch" href="/sz-docs/assets/js/49.56faf412.js"><link rel="prefetch" href="/sz-docs/assets/js/5.dac787d8.js"><link rel="prefetch" href="/sz-docs/assets/js/50.9bf5d2ab.js"><link rel="prefetch" href="/sz-docs/assets/js/51.5dc46630.js"><link rel="prefetch" href="/sz-docs/assets/js/52.a912ec7d.js"><link rel="prefetch" href="/sz-docs/assets/js/53.67bb5c60.js"><link rel="prefetch" href="/sz-docs/assets/js/54.2c797ca7.js"><link rel="prefetch" href="/sz-docs/assets/js/55.3580bd84.js"><link rel="prefetch" href="/sz-docs/assets/js/56.5252541f.js"><link rel="prefetch" href="/sz-docs/assets/js/57.3f36d034.js"><link rel="prefetch" href="/sz-docs/assets/js/58.609e0a8b.js"><link rel="prefetch" href="/sz-docs/assets/js/59.b3529e96.js"><link rel="prefetch" href="/sz-docs/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/sz-docs/assets/js/60.d52adccd.js"><link rel="prefetch" href="/sz-docs/assets/js/61.990276f0.js"><link rel="prefetch" href="/sz-docs/assets/js/62.e42f2df7.js"><link rel="prefetch" href="/sz-docs/assets/js/63.34f79dc1.js"><link rel="prefetch" href="/sz-docs/assets/js/7.307492ca.js"><link rel="prefetch" href="/sz-docs/assets/js/8.2b132dc4.js"><link rel="prefetch" href="/sz-docs/assets/js/9.3c5a8fdb.js">
    <link rel="stylesheet" href="/sz-docs/assets/css/0.styles.677476a9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sz-docs/" class="home-link router-link-active"><!----> <span class="site-name">生椰拿铁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  文章
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  文章
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/sz-docs/guide/万字解析 - React Fiber架构.html" class="sidebar-link">第1期：万字解析 - React Fiber架构</a></li><li><a href="/sz-docs/guide/Svelte，未来十年可能取代React和Vue等其他框架的新兴技术.html" class="sidebar-link">第2期：未来之星 - Svelte</a></li><li><a href="/sz-docs/guide/一看就会 - Git篇.html" class="sidebar-link">第3期：一看就会 - Git篇</a></li><li><a href="/sz-docs/guide/意博趣深 - RxJS.html" class="sidebar-link">第4期：意博趣深 - RxJS</a></li><li><a href="/sz-docs/guide/一劳永逸 - CSS布局.html" class="sidebar-link">第5期（上）：一劳永逸 - CSS布局</a></li><li><a href="/sz-docs/guide/CSS前生今世.html" class="sidebar-link">第5期（下）：一劳永逸 - CSS前生今世</a></li><li><a href="/sz-docs/guide/降维打击-Webpack对我们的代码做了什么？.html" class="sidebar-link">第6期：降维打击-Webpack对我们的代码做了什么？</a></li><li><a href="/sz-docs/guide/轮播图篇.html" class="sidebar-link">第7期：相见恨晚 - 轮播图篇</a></li><li><a href="/sz-docs/guide/TypeScript上.html" class="sidebar-link">第8期（上）：通俗易懂 - TypeScript(上)</a></li><li><a href="/sz-docs/guide/TypeScript下.html" class="sidebar-link">第8期（下）：通俗易懂-TypeScript(下)</a></li><li><a href="/sz-docs/guide/从koa到oak.html" class="sidebar-link">第9期：谁主沉浮 - 从koa到oak</a></li><li><a href="/sz-docs/guide/数字空间 - 如何提供稳定可靠服务？.html" class="sidebar-link">第10期：数字空间 - 如何提供稳定可靠服务？</a></li><li><a href="/sz-docs/guide/序列比对-Smith–Waterman算法.html" class="sidebar-link">第11期（上）：序列比对-Smith–Waterman算法</a></li><li><a href="/sz-docs/guide/图布局算法-Sugiyama算法框架.html" class="sidebar-link">第11期（下）：图布局算法-Sugiyama算法框架</a></li><li><a href="/sz-docs/guide/数组进阶 - 数组学到什么样才算精通.html" class="sidebar-link">第12期（上）：数组进阶 - 数组学到什么样才算精通</a></li><li><a href="/sz-docs/guide/复杂度分析 - 这可能是你见过的最好的复杂度分析文章.html" class="sidebar-link">第12期（中）：复杂度分析 - 这可能是你见过的最好的复杂度分析文章</a></li><li><a href="/sz-docs/guide/散列表与二分查找.html" class="sidebar-link">第12期（下）：散列表与二分查找</a></li><li><a href="/sz-docs/guide/Promise漫谈.html" class="sidebar-link">第13期：一诺千金 - Promise漫谈</a></li><li><a href="/sz-docs/guide/编译原理 - 抽象语法树（Abstract Syntax Tree，AST）.html" class="sidebar-link">第14期：编译原理 - 抽象语法树（Abstract Syntax Tree，AST）</a></li><li><a href="/sz-docs/guide/如何写出健壮的CSS.html" class="sidebar-link">第15期（上）：得心应手 - 如何写出健壮的CSS</a></li><li><a href="/sz-docs/guide/CSS3的世界.html" class="sidebar-link">第15期（上）：得心应手 - CSS3的世界</a></li><li><a href="/sz-docs/guide/正则表达式.html" class="sidebar-link">第16期：如鱼得水 - 正则表达式</a></li><li><a href="/sz-docs/guide/由一道面试题想到的.html" class="sidebar-link">第17期：由一道面试题想到的</a></li><li><a href="/sz-docs/guide/浅谈移动端.html" class="sidebar-link">第18期：手机时代 - 浅谈移动端</a></li><li><a href="/sz-docs/guide/js设计模式思想之策略模式思想与发布订阅模式思想.html" class="sidebar-link">第19期： 代码重构 - 浅谈策略模式思想与发布-订阅模式思想</a></li><li><a href="/sz-docs/guide/第二十期：手写系列-简易webpack编译过程.html" class="sidebar-link">第20期：手写系列 - 简易webpack编译过程</a></li><li><a href="/sz-docs/guide/Vite pourquoi si vite.html" class="sidebar-link">第21期：Vite pourquoi si vite</a></li><li><a href="/sz-docs/guide/WebAssembly.html" class="sidebar-link">第22期：未来已来 - WebAssembly</a></li><li><a href="/sz-docs/guide/浅谈数据压缩.html" class="sidebar-link">第23期：浅谈数据压缩</a></li><li><a href="/sz-docs/guide/第二十四期：Apache POI Excel 和 EasyExcel——读写Excel.html" class="sidebar-link">第24期：Apache POI Excel 和 EasyExcel——读写Excel</a></li><li><a href="/sz-docs/guide/第二十五期：浅谈多线程.html" class="sidebar-link">第25期：浅谈多线程</a></li><li><a href="/sz-docs/guide/霍夫曼编码-Huffman Coding.html" class="sidebar-link">第26期：霍夫曼编码-Huffman Coding</a></li><li><a href="/sz-docs/guide/聚类基础-KMean和均值漂移聚类.html" class="sidebar-link">第27期：聚类基础-KMean和均值漂移聚类</a></li><li><a href="/sz-docs/guide/web性能优化.html" class="sidebar-link">第28期：web性能优化</a></li><li><a href="/sz-docs/guide/第二十九期：分包吗 - Webpack.html" class="sidebar-link">第29期：分包吗 - Webpack</a></li><li><a href="/sz-docs/guide/TypeScript类型编程.html" class="sidebar-link">第30期：类型体操 - TypeScript类型编程</a></li><li><a href="/sz-docs/guide/Javasript设计模式之状态模式和代理模式.html" class="sidebar-link">第31期（上）：Javasript设计模式之状态模式和代理模式</a></li><li><a href="/sz-docs/guide/Javasript设计模式之工厂模式和装饰器模式.html" class="sidebar-link">第31期（下）：Javasript设计模式之工厂模式和装饰器模式</a></li><li><a href="/sz-docs/guide/ahooks-一套方便且实用的React Hooks库.html" class="sidebar-link">第32期：ahooks-一套方便且实用的React Hooks库</a></li><li><a href="/sz-docs/guide/Babel-通天塔.html" class="sidebar-link">第33期：Babel-通天塔</a></li><li><a href="/sz-docs/guide/Canvas.html" class="sidebar-link">第34期：Canvas-全集宝典</a></li><li><a href="/sz-docs/guide/WebSocket原理.html" class="sidebar-link">第35期：WebSocket原理</a></li><li><a href="/sz-docs/guide/操作系统——前言.html" class="sidebar-link">第36期：操作系统——前言</a></li><li><a href="/sz-docs/guide/WebSocket数据加密.html" class="active sidebar-link"> 第37期：WebSocket数据加密</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/WebSocket数据加密.html#回顾" class="sidebar-link">回顾</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/WebSocket数据加密.html#数据加密" class="sidebar-link">数据加密</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/WebSocket数据加密.html#加密方式" class="sidebar-link">加密方式</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/WebSocket数据加密.html#加密算法" class="sidebar-link">加密算法</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/WebSocket数据加密.html#数据解密" class="sidebar-link">数据解密</a></li></ul></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/WebSocket数据加密.html#数据掩码的作用" class="sidebar-link">数据掩码的作用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sz-docs/guide/WebSocket数据加密.html#代理缓存污染攻击" class="sidebar-link">代理缓存污染攻击</a></li><li class="sidebar-sub-header"><a href="/sz-docs/guide/WebSocket数据加密.html#当前解决方案" class="sidebar-link">当前解决方案</a></li></ul></li></ul></li><li><a href="/sz-docs/guide/Redis五种数据类型实现.html" class="sidebar-link">第38期：Redis五种数据类型实现</a></li><li><a href="/sz-docs/guide/操作系统——启动流程.html" class="sidebar-link">第39期：操作系统——启动流程</a></li><li><a href="/sz-docs/guide/Docker初识.html" class="sidebar-link">第40期：Docker初识</a></li><li><a href="/sz-docs/guide/webpack-runtime.html" class="sidebar-link">第41期：揭开WebpackRuntime的面纱</a></li><li><a href="/sz-docs/guide/grid layout.html" class="sidebar-link">第42期：前端布局大法之grid布局</a></li><li><a href="/sz-docs/guide/Vuejs 3.X源码解析---渲染流程.html" class="sidebar-link">第43期：Vuejs 3.X源码解析---渲染流程</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="回顾"><a href="#回顾" class="header-anchor">#</a> 回顾</h2> <p>在上一篇<a href="https://wiki.uino.com/d/62b944c2b33e6f3a465b6fbf.html" target="_blank" rel="noopener noreferrer">《WebSocket原理》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，简单介绍了WebSocket与HTTP的不同、握手环节、以及基于数据帧格式的数据传输。</p> <p>WebSocket复用了HTTP的握手通道，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则按照WebSocket的协议。</p> <p>与HTTP不同的一点是：HTTP只需要数据传输/收发数据就可以了。</p> <p>而WebScoket在它底层其实是有一套加密机制的。</p> <p>比如：我通过WebSocket客户端发送了一句“你好”，在浏览器的底层它会对“你好”进行加密，加完密之后，它是密文，会通过网络传送给服务器，服务器接收到这个密文后，会进行解密。</p> <p>那这个加密和解密过程是怎样的呢？今天我们就来一起研究研究。</p> <h2 id="数据加密"><a href="#数据加密" class="header-anchor">#</a> 数据加密</h2> <h3 id="加密方式"><a href="#加密方式" class="header-anchor">#</a> 加密方式</h3> <p>我们再次 Look一Look 数据帧的格式，理解这张图，对数据的加解密非常重要。</p> <p><img src="https://pan.udolphin.com/files/image/2022/8/a7462bd8b6e33f0ec2d0ca8c6176cdab.png" alt=""></p> <p>细心的小伙伴可能会发现这张表里有2个单词：MASK、Masking-key 。</p> <p>mask翻译成中文的意思是：掩码。</p> <p>没错WebSocket底层就是使用掩码进行加解密的。</p> <p><strong>mask</strong>:</p> <p>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。</p> <p>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p> <p>如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。</p> <p><strong>Masking-key</strong>：0或4字节（32位）</p> <p>浏览器随机生成的32位（4字节）数。所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。</p> <p>备注：载荷数据的长度，不包括masking key的长度。</p> <p>表里的其他字段的含义可以看我上一篇文章<a href="https://wiki.uino.com/d/62b944c2b33e6f3a465b6fbf.html" target="_blank" rel="noopener noreferrer">《WebSocket原理》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h3 id="加密算法"><a href="#加密算法" class="header-anchor">#</a> 加密算法</h3> <p>掩码一般都伴随着位运算，在详细介绍加密算法之前，我们先说一下异或（XOR）运算。看下图：</p> <p><img src="https://pan.udolphin.com/files/image/2022/8/4e31fba33c1709125bf5c81282252f57.png" alt=""></p> <p>具体来说，异或运算就是：如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0</p> <p>并且原始值被异或后，可以通过同一个值再异或回原始值，这个过程可以理解成对称加密。</p> <p>知道了异或运算后，我们再来看看WebSocket底层是怎么对数据进行掩码计算的：</p> <div class="language- extra-class"><pre class="language-text"><code>j = i MOD 4

transformed-octet-i = original-octet-i XOR masking-key-octet-j
</code></pre></div><ul><li>original-octet-i为原始数据的第i字节</li> <li>transformed-octet-i为转换后的数据的第i字节</li> <li>masking-key-octet-j 表示 Masking-key 的第 j 个字节</li> <li>j为i mod 4的结果 (mod是取模的意思)</li></ul> <h3 id="数据解密"><a href="#数据解密" class="header-anchor">#</a> 数据解密</h3> <p>数据解密的过程也是才用的同一套掩码算法，只是由于Payload length的不同，会出现若干种情况：</p> <ol><li>读取 9-15(包括) 位并将其解析为无符号整型。如果长度小于等于 125，那么就是长度;你就完成了。如果是 126，到第二步。如果是 127，到步骤 3。</li> <li>读取下面的 16 位，并将其解释为无符号整型。你就完成了。</li> <li>读取接下来的 64 位，并将其解释为无符号整型 (最重要的位必须为 0)。</li></ol> <p>伪代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>function read_msg(data) {
  let str2 = data[1].toString(2);     // 将第二个字节转换为二进制的字符串形式
  let msg_len = parseInt(str2.slice(1), 2); // 数据载荷(payload length)的长度
  if (msg_len == 126) {
    // 如果payload length的长度为126，则后面的两个字节（16位）内容应该被识别成一个16位的二进制数表示数据内容大小
    mask = data.slice(4, 8); // Mask 掩码
    content = data.slice(8); // 消息内容
  } else if (msg_len == 127) {
    // 如果payload length的长度为127，则后面的8个字节（64位）内容应该被识别成一个64位的二进制数表示数据内容大小
    mask = data.slice(10, 14);
    content = data.slice(14);
  } else {
    // 如果payload length的长度&lt;=125
    mask = data.slice(2, 6);
    content = data.slice(6);
  }

  let DECODED = &quot;&quot;; // 解码后的内容
  for (let i = 0; i &lt; content.length; i++) {
    DECODED[i] = content[i] ^ mask[i % 4];
  }
  return DECODED;
}
</code></pre></div><h2 id="数据掩码的作用"><a href="#数据掩码的作用" class="header-anchor">#</a> 数据掩码的作用</h2> <p>WebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p> <p>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。</p> <p>答案还是两个字：<strong>安全</strong>。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p> <h3 id="代理缓存污染攻击"><a href="#代理缓存污染攻击" class="header-anchor">#</a> 代理缓存污染攻击</h3> <p><img src="https://pan.udolphin.com/files/image/2022/8/beeb1013421e9a80f02a2e8aa5164eda.png" alt=""></p> <p>攻击步骤一：</p> <ol><li><strong>攻击者</strong>浏览器 向 <strong>邪恶服务器</strong> 发起WebSocket连接。根据前文，首先是一个协议升级请求。</li> <li>协议升级请求 实际到达 <strong>代理服务器</strong>。</li> <li><strong>代理服务器</strong> 将协议升级请求转发到 <strong>邪恶服务器</strong>。</li> <li><strong>邪恶服务器</strong> 同意连接，<strong>代理服务器</strong> 将响应转发给 <strong>攻击者</strong>。</li></ol> <p>由于 upgrade 的实现上有缺陷，<strong>代理服务器</strong> 以为之前转发的是普通的HTTP消息。因此，当<strong>邪恶服务器</strong> 同意连接，<strong>代理服务器</strong> 以为本次会话已经结束。</p> <p>攻击步骤二：</p> <ol><li><strong>攻击者</strong> 在之前建立的连接上，通过WebSocket的接口向 <strong>邪恶服务器</strong> 发送数据，且数据是精心构造的HTTP格式的文本。其中包含了 <strong>正义资源</strong> 的地址，以及一个伪造的host（指向<strong>正义服务器</strong>）。（见后面报文）</li> <li>请求到达 <strong>代理服务器</strong> 。虽然复用了之前的TCP连接，但 <strong>代理服务器</strong> 以为是新的HTTP请求。</li> <li><strong>代理服务器</strong> 向 <strong>邪恶服务器</strong> 请求 <strong>邪恶资源</strong>。</li> <li><strong>邪恶服务器</strong> 返回 <strong>邪恶资源</strong>。<strong>代理服务器</strong> 缓存住 <strong>邪恶资源</strong>（url是对的，但host是 <strong>正义服务器</strong> 的地址）。</li></ol> <p>到这里，受害者可以登场了：</p> <ol><li><strong>受害者</strong> 通过 <strong>代理服务器</strong> 访问 <strong>正义服务器</strong> 的 <strong>正义资源</strong>。</li> <li><strong>代理服务器</strong> 检查该资源的url、host，发现本地有一份缓存（伪造的）。</li> <li><strong>代理服务器</strong> 将 <strong>邪恶资源</strong> 返回给 <strong>受害者</strong>。</li> <li><strong>受害者</strong> GG。</li></ol> <p>缓存污染的核心在于能够让代理服务器缓存伪造的响应。 假设浏览器没有任何安全策略，恶意页面能够控制浏览器请求发送行为，那么恶意页面可以按照如下流程发起缓存伪造攻击：</p> <p>1、发起<mark>第一</mark>个HTTP请求（HOST为恶意域名），建立与恶意服务器的长连接</p> <p>2、复用该长连接，发起第二个HTTP请求（HOST为被攻击域名），请求到达恶意服务器</p> <p>3、恶意服务器返回伪造响应，被代理服务器缓存</p> <p>4、用户访问被攻击域名，代理服务器返回已经缓存的伪造响应，正常用户请求无法到达被攻击域名 这个攻击过程在用户使用正常浏览器情况下是无法实现的，因为第二个HTTP请求无法复用<mark>第一</mark>个HTTP请求所建立的长连接。</p> <p>有了WebSocket协议后，恶意页面可以通过WebSocket协议建立与恶意服务器的长连接，并且发送一个格式符合HTTP规范的数据帧，由于代理服务器不支持WebSocket，会将该数据帧识别为HTTP请求并转发给恶意服务器，这样恶意服务器就可以返回伪造响应给代理服务器。</p> <h3 id="当前解决方案"><a href="#当前解决方案" class="header-anchor">#</a> 当前解决方案</h3> <p>最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。 有了掩码机制后，恶意页面无法控制实际发送的数据，即使恶意页面构造了一个符合HTTP规范的数据帧，经过掩码后，数据已经不再符合HTTP规范，代理服务器无法识别，会关闭连接。 需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的WebSocket客户端、服务端，不按规则来，攻击可以照常进行。 但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。</p> <p>以上就是关于WebSocket数据加密的介绍，WebSocket还有很多有趣的东西值得去探究，欢迎感兴趣的小伙伴可以和我一起探究探究</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/sz-docs/guide/操作系统——前言.html" class="prev">
        第36期：操作系统——前言
      </a></span> <span class="next"><a href="/sz-docs/guide/Redis五种数据类型实现.html">
        第38期：Redis五种数据类型实现
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/sz-docs/assets/js/app.5b32c35c.js" defer></script><script src="/sz-docs/assets/js/2.733019b2.js" defer></script><script src="/sz-docs/assets/js/29.745520d1.js" defer></script>
  </body>
</html>
